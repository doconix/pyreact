{
	"version": 3,
	"file": "scripts/__javascript__/index.js",
	"sources": [
		"",
		"/usr/local/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__core__.mod.js",
		"/usr/local/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__base__.py",
		"/usr/local/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__standard__.py",
		"/usr/local/lib/python3.6/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__builtin__.mod.js",
		"scripts/clock.py",
		"scripts/pyreact.py",
		"/usr/local/lib/python3.6/site-packages/transcrypt/modules/random/__init__.py",
		"/usr/local/lib/python3.6/site-packages/transcrypt/modules/re/__init__.py",
		"/usr/local/lib/python3.6/site-packages/transcrypt/modules/re/translate.py",
		"scripts/index.py"
	],
	"sourcesContent": [
		"__pragma__ ('padding')",
		"    var __all__ = {};\n    var __world__ = __all__;\n    \n    // Nested object creator, part of the nesting may already exist and have attributes\n    var __nest__ = function (headObject, tailNames, value) {\n        // In some cases this will be a global object, e.g. 'window'\n        var current = headObject;\n        \n        if (tailNames != '') {  // Split on empty string doesn't give empty list\n            // Find the last already created object in tailNames\n            var tailChain = tailNames.split ('.');\n            var firstNewIndex = tailChain.length;\n            for (var index = 0; index < tailChain.length; index++) {\n                if (!current.hasOwnProperty (tailChain [index])) {\n                    firstNewIndex = index;\n                    break;\n                }\n                current = current [tailChain [index]];\n            }\n            \n            // Create the rest of the objects, if any\n            for (var index = firstNewIndex; index < tailChain.length; index++) {\n                current [tailChain [index]] = {};\n                current = current [tailChain [index]];\n            }\n        }\n        \n        // Insert it new attributes, it may have been created earlier and have other attributes\n        for (var attrib in value) {\n            current [attrib] = value [attrib];          \n        }       \n    };\n    __all__.__nest__ = __nest__;\n    \n    // Initialize module if not yet done and return its globals\n    var __init__ = function (module) {\n        if (!module.__inited__) {\n            module.__all__.__init__ (module.__all__);\n            module.__inited__ = true;\n        }\n        return module.__all__;\n    };\n    __all__.__init__ = __init__;\n    \n    \n__pragma__ ('ifdef', '__esv6__')\n    // Proxy switch, controlled by __pragma__ ('proxy') and __pragma ('noproxy')\n    var __proxy__ = false;  // No use assigning it to __all__, only its transient state is important\n__pragma__ ('endif')\n    \n    \n    // Since we want to assign functions, a = b.f should make b.f produce a bound function\n    // So __get__ should be called by a property rather then a function\n    // Factory __get__ creates one of three curried functions for func\n    // Which one is produced depends on what's to the left of the dot of the corresponding JavaScript property\n    var __get__ = function (self, func, quotedFuncName) {\n        if (self) {\n            if (self.hasOwnProperty ('__class__') || typeof self == 'string' || self instanceof String) {           // Object before the dot\n                if (quotedFuncName) {                                   // Memoize call since fcall is on, by installing bound function in instance\n                    Object.defineProperty (self, quotedFuncName, {      // Will override the non-own property, next time it will be called directly\n                        value: function () {                            // So next time just call curry function that calls function\n                            var args = [] .slice.apply (arguments);\n                            return func.apply (null, [self] .concat (args));\n                        },              \n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n                return function () {                                    // Return bound function, code dupplication for efficiency if no memoizing\n                    var args = [] .slice.apply (arguments);             // So multilayer search prototype, apply __get__, call curry func that calls func\n                    return func.apply (null, [self] .concat (args));\n                };\n            }\n            else {                                                      // Class before the dot\n                return func;                                            // Return static method\n            }\n        }\n        else {                                                          // Nothing before the dot\n            return func;                                                // Return free function\n        }\n    }\n    __all__.__get__ = __get__;\n\n    var __getcm__ = function (self, func, quotedFuncName) {\n        if (self.hasOwnProperty ('__class__')) {\n            return function () {\n                var args = [] .slice.apply (arguments);\n                return func.apply (null, [self.__class__] .concat (args));\n            };\n        }\n        else {\n            return function () {\n                var args = [] .slice.apply (arguments);\n                return func.apply (null, [self] .concat (args));\n            };\n        }\n    }\n    __all__.__getcm__ = __getcm__;\n    \n    var __getsm__ = function (self, func, quotedFuncName) {\n        return func;\n    }\n    __all__.__getsm__ = __getsm__;\n        \n    // Mother of all metaclasses        \n    var py_metatype = {\n        __name__: 'type',\n        __bases__: [],\n        \n        // Overridable class creation worker\n        __new__: function (meta, name, bases, attribs) {\n            // Create the class cls, a functor, which the class creator function will return\n            var cls = function () {                     // If cls is called with arg0, arg1, etc, it calls its __new__ method with [arg0, arg1, etc]\n                var args = [] .slice.apply (arguments); // It has a __new__ method, not yet but at call time, since it is copied from the parent in the loop below\n                return cls.__new__ (args);              // Each Python class directly or indirectly derives from object, which has the __new__ method\n            };                                          // If there are no bases in the Python source, the compiler generates [object] for this parameter\n            \n            // Copy all methods, including __new__, properties and static attributes from base classes to new cls object\n            // The new class object will simply be the prototype of its instances\n            // JavaScript prototypical single inheritance will do here, since any object has only one class\n            // This has nothing to do with Python multiple inheritance, that is implemented explictly in the copy loop below\n            for (var index = bases.length - 1; index >= 0; index--) {   // Reversed order, since class vars of first base should win\n                var base = bases [index];\n                for (var attrib in base) {\n                    var descrip = Object.getOwnPropertyDescriptor (base, attrib);\n                    Object.defineProperty (cls, attrib, descrip);\n                }           \n__pragma__ ('ifdef', '__esv6__')\n\n                for (var symbol of Object.getOwnPropertySymbols (base)) {\n                    var descrip = Object.getOwnPropertyDescriptor (base, symbol);\n                    Object.defineProperty (cls, symbol, descrip);\n                }\n                \n__pragma__ ('endif')\n            }\n            \n            // Add class specific attributes to the created cls object\n            cls.__metaclass__ = meta;\n            cls.__name__ = name;\n            cls.__bases__ = bases;\n            \n            // Add own methods, properties and own static attributes to the created cls object\n            for (var attrib in attribs) {\n                var descrip = Object.getOwnPropertyDescriptor (attribs, attrib);\n                Object.defineProperty (cls, attrib, descrip);\n            }\n__pragma__ ('ifdef', '__esv6__')\n\n            for (var symbol of Object.getOwnPropertySymbols (attribs)) {\n                var descrip = Object.getOwnPropertyDescriptor (attribs, symbol);\n                Object.defineProperty (cls, symbol, descrip);\n            }\n            \n__pragma__ ('endif')\n            // Return created cls object\n            return cls;\n        }\n    };\n    py_metatype.__metaclass__ = py_metatype;\n    __all__.py_metatype = py_metatype;\n    \n    // Mother of all classes\n    var object = {\n        __init__: function (self) {},\n        \n        __metaclass__: py_metatype, // By default, all classes have metaclass type, since they derive from object\n        __name__: 'object',\n        __bases__: [],\n            \n        // Object creator function, is inherited by all classes (so could be global)\n        __new__: function (args) {  // Args are just the constructor args       \n            // In JavaScript the Python class is the prototype of the Python object\n            // In this way methods and static attributes will be available both with a class and an object before the dot\n            // The descriptor produced by __get__ will return the right method flavor\n            var instance = Object.create (this, {__class__: {value: this, enumerable: true}});\n            \n__pragma__ ('ifdef', '__esv6__')\n            if ('__getattr__' in this || '__setattr__' in this) {\n                instance = new Proxy (instance, {\n                    get: function (target, name) {\n                        var result = target [name];\n                        if (result == undefined) {  // Target doesn't have attribute named name\n                            return target.__getattr__ (name);\n                        }\n                        else {\n                            return result;\n                        }\n                    },\n                    set: function (target, name, value) {\n                        try {\n                            target.__setattr__ (name, value);\n                        }\n                        catch (exception) {         // Target doesn't have a __setattr__ method\n                            target [name] = value;\n                        }\n                        return true;\n                    }\n                })\n            }\n__pragma__ ('endif')\n\n            // Call constructor\n            this.__init__.apply (null, [instance] .concat (args));\n\n            // Return constructed instance\n            return instance;\n        }   \n    };\n    __all__.object = object;\n    \n    // Class creator facade function, calls class creation worker\n    var __class__ = function (name, bases, attribs, meta) {         // Parameter meta is optional\n        if (meta == undefined) {\n            meta = bases [0] .__metaclass__;\n        }\n                \n        return meta.__new__ (meta, name, bases, attribs);\n    }\n    __all__.__class__ = __class__;\n    \n    // Define __pragma__ to preserve '<all>' and '</all>', since it's never generated as a function, must be done early, so here\n    var __pragma__ = function () {};\n    __all__.__pragma__ = __pragma__;\n    \n    ",
		"# This module is avaible both in the Python and Transcrypt environments\n# It is included in-between the __core__ and the __builtin__ module, so the latter can adapt __envir__\n# In Transcrypt, __base__ is available inline, it isn't nested and cannot be imported in the normal way\n\nclass __Envir__:\n    def __init__ (self):\n        self.interpreter_name = 'python'\n        self.transpiler_name = 'transcrypt'\n        self.transpiler_version = '3.6.54'\n        self.target_subdir = '__javascript__'\n        \n__envir__ = __Envir__ ()",
		"# This module is avaible solely in the Transcrypt environment\n# It is included after the __builtin__ module, since it uses its facilities\n# In Transcrypt, __standard__ is available inline, it isn't nested and cannot be imported in the normal way\n\n__pragma__ ('skip')\ncopy = Math = __typeof__ = __repr__ = document = console = window = 0\n__pragma__ ('noskip')\n\n__pragma__ ('notconv')  # !!! tconv gives a problem with __terminal__, needs investigation\n__pragma__ ('nokwargs')\n__pragma__ ('noalias', 'sort')\n\nclass Exception:\n    __pragma__ ('kwargs')\n    def __init__ (self, *args, **kwargs):\n        self.__args__ = args\n        try:\n            self.stack = kwargs.error.stack # Integrate with JavaScript Error object\n        except:\n            self.stack = 'No stack trace available'\n    __pragma__ ('nokwargs')\n        \n    def __repr__ (self):\n        if len (self.__args__):\n            return '{}{}'.format (self.__class__.__name__, repr (tuple (self.__args__)))\n        else:\n            return '{}()'.format (self.__class__.__name__)\n            \n    def __str__ (self):\n        if len (self.__args__) > 1:\n            return str (tuple (self.__args__))\n        elif len (self.__args__):\n            return str (self.__args__ [0])\n        else:\n            return ''\n        \nclass IterableError (Exception):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Can\\'t iterate over non-iterable', error = error)\n            \nclass StopIteration (Exception):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Iterator exhausted', error = error)\n        \nclass ValueError (Exception,):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Erroneous value', error = error)\n    \nclass KeyError (Exception,):\n    def __init__ (self, error):\n        Exception.__init__ (self, 'Invalid key', error = error)\n    \nclass AssertionError (Exception):\n    def __init__ (self, message, error):\n        if message:\n            Exception.__init__ (self, message, error = error)\n        else:\n            Exception.__init__ (self, error = error)\n\nclass NotImplementedError (Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\nclass IndexError(Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\nclass AttributeError(Exception):\n    def __init__(self, message, error):\n        Exception.__init__(self, message, error = error)\n\n# Warnings Exceptions\n# N.B. This is a limited subset of the warnings defined in\n# the cpython implementation to keep things small for now.\n\nclass Warning (Exception):\n    ''' Warning Base Class\n    '''\n    pass\n\nclass UserWarning (Warning):\n    pass\n\nclass DeprecationWarning (Warning):\n    pass\n\nclass RuntimeWarning (Warning):\n    pass\n\n__pragma__ ('kwargs')\n\ndef __sort__ (iterable, key = None, reverse = False):               # Used by py_sort, can deal with kwargs\n    if key:\n        iterable.sort (lambda a, b: 1 if key (a) > key (b) else -1) # JavaScript sort, case '==' is irrelevant for sorting\n    else:\n        iterable.sort ()                                            # JavaScript sort\n        \n    if reverse:\n        iterable.reverse ()\n        \ndef sorted (iterable, key = None, reverse = False):\n    if type (iterable) == dict:\n        result = copy (iterable.keys ()) \n    else:       \n        result = copy (iterable)\n        \n    __sort__ (result, key, reverse)\n    return result\n\n__pragma__ ('nokwargs')\n\ndef map (func, iterable):\n    return [func (item) for item in iterable]\n\n\ndef filter (func, iterable):\n    if func == None:\n        func = bool\n    return [item for item in iterable if func (item)]\n    \n__pragma__ ('ifdef', '__complex__')\nclass complex:\n    def __init__ (self, real, imag = None):\n        if imag == None:\n            if type (real) == complex:\n                self.real = real.real\n                self.imag = real.imag\n            else:\n                self.real = real\n                self.imag = 0\n        else:\n            self.real = real\n            self.imag = imag\n            \n    def __neg__ (self):\n        return complex (-self.real, -self.imag)\n        \n    def __exp__ (self):\n        modulus = Math.exp (self.real)\n        return complex (modulus * Math.cos (self.imag), modulus * Math.sin (self.imag))\n    \n    def __log__ (self):\n        return complex (Math.log (Math.sqrt (self.real * self.real + self.imag * self.imag)), Math.atan2 (self.imag, self.real))\n        \n    def __pow__ (self, other):  # a ** b = exp (b log a)\n        return (self.__log__ () .__mul__ (other)) .__exp__ ()\n        \n    def __rpow__ (self, real):  # real ** comp -> comp.__rpow__ (real)\n        return self.__mul__ (Math.log (real)) .__exp__ ()\n        \n    def __mul__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real * other, self.imag * other)\n        else:\n            return complex (self.real * other.real - self.imag * other.imag, self.real * other.imag + self.imag * other.real)\n        \n    def __rmul__ (self, real):  # real + comp -> comp.__rmul__ (real)\n        return complex (self.real * real, self.imag * real)\n        \n    def __div__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real / other, self.imag / other)\n        else:\n            denom = other.real * other.real + other.imag * other.imag\n            return complex (\n                (self.real * other.real + self.imag * other.imag) / denom,\n                (self.imag * other.real - self.real * other.imag) / denom\n            )\n        \n    def __rdiv__ (self, real):  # real / comp -> comp.__rdiv__ (real)\n        denom = self.real * self.real\n        return complex (\n            (real * self.real) / denom,\n            (real * self.imag) / denom\n        )\n        \n    def __add__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real + other, self.imag)\n        else:   # Assume other is complex\n            return complex (self.real + other.real, self.imag + other.imag)\n        \n    def __radd__ (self, real):  # real + comp -> comp.__radd__ (real)\n        return complex (self.real + real, self.imag)\n        \n    def __sub__ (self, other):\n        if __typeof__ (other) is 'number':\n            return complex (self.real - other, self.imag)\n        else:\n            return complex (self.real - other.real, self.imag - other.imag)\n        \n    def __rsub__ (self, real):  # real - comp -> comp.__rsub__ (real)\n        return complex (real - self.real, -self.imag)\n        \n    def __repr__ (self):\n        return '({}{}{}j)'.format (self.real, '+' if self.imag >= 0 else '', self.imag)\n            \n    def __str__ (self):\n        return __repr__ (self) [1 : -1]\n        \n__pragma__ ('endif')\n\nclass __Terminal__:\n    '''\n    Printing to either the console or to html happens async, but is blocked by calling window.prompt.\n    So while all input and print statements are encountered in normal order, the print's exit immediately without yet having actually printed\n    This means the next input takes control, blocking actual printing and so on indefinitely\n    The effect is that everything's only printed after all inputs are done\n    To prevent that, what's needed is to only execute the next window.prompt after actual printing has been done\n    Since we've no way to find out when that is, a timeout is used.\n    '''\n\n    def __init__ (self):\n        self.buffer = ''\n    \n        try:\n            self.element = document.getElementById ('__terminal__')\n        except:\n            self.element = None\n            \n        if self.element:\n            self.element.style.overflowX = 'auto'\n            self.element.style.boxSizing = 'border-box'\n            self.element.style.padding = '5px'\n            self.element.innerHTML = '_'\n        \n    __pragma__ ('kwargs')\n        \n    def print (self, *args, sep = ' ', end = '\\n'):\n        self.buffer = '{}{}{}'.format (self.buffer, sep.join ([str (arg) for arg in args]), end) [-4096 : ] \n        \n        if self.element:\n            self.element.innerHTML = self.buffer.replace ('\\n', '<br>')\n            self.element.scrollTop = self.element.scrollHeight\n        else:\n            console.log (sep.join ([str (arg) for arg in args]))\n        \n    def input (self, question):\n        self.print ('{}'.format (question), end = '')\n        answer = window.prompt ('\\n'.join (self.buffer.split ('\\n') [-16:]))\n        self.print (answer)\n        return answer\n        \n    __pragma__ ('nokwargs')\n    \n__terminal__ = __Terminal__ ()\n",
		"    var __call__ = function (/* <callee>, <this>, <params>* */) {   // Needed for __base__ and __standard__ if global 'opov' switch is on\n        var args = [] .slice.apply (arguments);\n        if (typeof args [0] == 'object' && '__call__' in args [0]) {        // Overloaded\n            return args [0] .__call__ .apply (args [1], args.slice (2));\n        }\n        else {                                                              // Native\n            return args [0] .apply (args [1], args.slice (2));\n        }\n    };\n    __all__.__call__ = __call__;\n\n    // Initialize non-nested modules __base__ and __standard__ and make its names available directly and via __all__\n    // They can't do that itself, because they're regular Python modules\n    // The compiler recognizes their names and generates them inline rather than nesting them\n    // In this way it isn't needed to import them everywhere\n\n    // __base__\n\n    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__base__));\n    var __envir__ = __all__.__envir__;\n\n    // __standard__\n\n    __nest__ (__all__, '', __init__ (__all__.org.transcrypt.__standard__));\n\n    var Exception = __all__.Exception;\n    var IterableError = __all__.IterableError;\n    var StopIteration = __all__.StopIteration;\n    var ValueError = __all__.ValueError;\n    var KeyError = __all__.KeyError;\n    var AssertionError = __all__.AssertionError;\n    var NotImplementedError = __all__.NotImplementedError;\n    var IndexError = __all__.IndexError;\n    var AttributeError = __all__.AttributeError;\n\n    // Warnings Exceptions\n    var Warning = __all__.Warning;\n    var UserWarning = __all__.UserWarning;\n    var DeprecationWarning = __all__.DeprecationWarning;\n    var RuntimeWarning = __all__.RuntimeWarning;\n\n    var __sort__ = __all__.__sort__;\n    var sorted = __all__.sorted;\n\n    var map = __all__.map;\n    var filter = __all__.filter;\n\n__pragma__ ('ifdef', '__complex__')\n    var complex = __all__.complex;\n__pragma__ ('endif')\n    __all__.print = __all__.__terminal__.print;\n    __all__.input = __all__.__terminal__.input;\n\n    var __terminal__ = __all__.__terminal__;\n    var print = __all__.print;\n    var input = __all__.input;\n\n    // Complete __envir__, that was created in __base__, for non-stub mode\n    __envir__.executor_name = __envir__.transpiler_name;\n\n    // Make make __main__ available in browser\n    var __main__ = {__file__: ''};\n    __all__.main = __main__;\n\n    // Define current exception, there's at most one exception in the air at any time\n    var __except__ = null;\n    __all__.__except__ = __except__;\n    \n     // Creator of a marked dictionary, used to pass **kwargs parameter\n    var __kwargtrans__ = function (anObject) {\n        anObject.__kwargtrans__ = null; // Removable marker\n        anObject.constructor = Object;\n        return anObject;\n    }\n    __all__.__kwargtrans__ = __kwargtrans__;\n\n    // 'Oneshot' dict promotor, used to enrich __all__ and help globals () return a true dict\n    var __globals__ = function (anObject) {\n        if (isinstance (anObject, dict)) {  // Don't attempt to promote (enrich) again, since it will make a copy\n            return anObject;\n        }\n        else {\n            return dict (anObject)\n        }\n    }\n    __all__.__globals__ = __globals__\n    \n    // Partial implementation of super () .<methodName> (<params>)\n    var __super__ = function (aClass, methodName) {\n        // Lean and fast, no C3 linearization, only call first implementation encountered\n        // Will allow __super__ ('<methodName>') (self, <params>) rather than only <className>.<methodName> (self, <params>)\n        \n__pragma__ ('ifdef', '__esv6__')\n        for (let base of aClass.__bases__) {\n__pragma__ ('else')\n        for (var index = 0; index < aClass.__bases__.length; index++) {\n            var base = aClass.__bases__ [index];\n__pragma__ ('endif')\n            if (methodName in base) {\n               return base [methodName];\n            }\n        }\n\n        throw new Exception ('Superclass method not found');    // !!! Improve!\n    }\n    __all__.__super__ = __super__\n        \n    // Python property installer function, no member since that would bloat classes\n    var property = function (getter, setter) {  // Returns a property descriptor rather than a property\n        if (!setter) {  // ??? Make setter optional instead of dummy?\n            setter = function () {};\n        }\n        return {get: function () {return getter (this)}, set: function (value) {setter (this, value)}, enumerable: true};\n    }\n    __all__.property = property;\n    \n    // Conditional JavaScript property installer function, prevents redefinition of properties if multiple Transcrypt apps are on one page\n    var __setProperty__ = function (anObject, name, descriptor) {\n        if (!anObject.hasOwnProperty (name)) {\n            Object.defineProperty (anObject, name, descriptor);\n        }\n    }\n    __all__.__setProperty__ = __setProperty__\n    \n    // Assert function, call to it only generated when compiling with --dassert option\n    function assert (condition, message) {  // Message may be undefined\n        if (!condition) {\n            throw AssertionError (message, new Error ());\n        }\n    }\n\n    __all__.assert = assert;\n\n    var __merge__ = function (object0, object1) {\n        var result = {};\n        for (var attrib in object0) {\n            result [attrib] = object0 [attrib];\n        }\n        for (var attrib in object1) {\n            result [attrib] = object1 [attrib];\n        }\n        return result;\n    };\n    __all__.__merge__ = __merge__;\n\n    // Manipulating attributes by name\n    \n    var dir = function (obj) {\n        var aList = [];\n        for (var aKey in obj) {\n            aList.push (aKey);\n        }\n        aList.sort ();\n        return aList;\n    };\n    __all__.dir = dir;\n\n    var setattr = function (obj, name, value) {\n        obj [name] = value;\n    };\n    __all__.setattr = setattr;\n\n    var getattr = function (obj, name) {\n        return obj [name];\n    };\n    __all__.getattr= getattr;\n\n    var hasattr = function (obj, name) {\n        try {\n            return name in obj;\n        }\n        catch (exception) {\n            return false;\n        }\n    };\n    __all__.hasattr = hasattr;\n\n    var delattr = function (obj, name) {\n        delete obj [name];\n    };\n    __all__.delattr = (delattr);\n\n    // The __in__ function, used to mimic Python's 'in' operator\n    // In addition to CPython's semantics, the 'in' operator is also allowed to work on objects, avoiding a counterintuitive separation between Python dicts and JavaScript objects\n    // In general many Transcrypt compound types feature a deliberate blend of Python and JavaScript facilities, facilitating efficient integration with JavaScript libraries\n    // If only Python objects and Python dicts are dealt with in a certain context, the more pythonic 'hasattr' is preferred for the objects as opposed to 'in' for the dicts\n    var __in__ = function (element, container) {\n        if (py_typeof (container) == dict) {        // Currently only implemented as an augmented JavaScript object\n            return container.hasOwnProperty (element);\n        }\n        else {                                      // Parameter 'element' itself is an array, string or a plain, non-dict JavaScript object\n            return (\n                container.indexOf ?                 // If it has an indexOf\n                container.indexOf (element) > -1 :  // it's an array or a string,\n                container.hasOwnProperty (element)  // else it's a plain, non-dict JavaScript object\n            );\n        }\n    };\n    __all__.__in__ = __in__;\n\n    // Find out if an attribute is special\n    var __specialattrib__ = function (attrib) {\n        return (attrib.startswith ('__') && attrib.endswith ('__')) || attrib == 'constructor' || attrib.startswith ('py_');\n    };\n    __all__.__specialattrib__ = __specialattrib__;\n\n    // Compute length of any object\n    var len = function (anObject) {\n        if (anObject === undefined || anObject === null) {\n            return 0;\n        }\n\n        if (anObject.__len__ instanceof Function) {\n            return anObject.__len__ ();\n        }\n\n        if (anObject.length !== undefined) {\n            return anObject.length;\n        }\n\n        var length = 0;\n        for (var attr in anObject) {\n            if (!__specialattrib__ (attr)) {\n                length++;\n            }\n        }\n\n        return length;\n    };\n    __all__.len = len;\n\n    // General conversions\n\n    function __i__ (any) {  //  Conversion to iterable\n        return py_typeof (any) == dict ? any.py_keys () : any;\n    }\n\n    // If the target object is somewhat true, return it. Otherwise return false.\n    // Try to follow Python conventions of truthyness\n    function __t__ (target) { \n        return (\n            // Avoid invalid checks\n            target === undefined || target === null ? false :\n            \n            // Take a quick shortcut if target is a simple type\n            ['boolean', 'number'] .indexOf (typeof target) >= 0 ? target :\n            \n            // Use __bool__ (if present) to decide if target is true\n            target.__bool__ instanceof Function ? (target.__bool__ () ? target : false) :\n            \n            // There is no __bool__, use __len__ (if present) instead\n            target.__len__ instanceof Function ?  (target.__len__ () !== 0 ? target : false) :\n            \n            // There is no __bool__ and no __len__, declare Functions true.\n            // Python objects are transpiled into instances of Function and if\n            // there is no __bool__ or __len__, the object in Python is true.\n            target instanceof Function ? target :\n            \n            // Target is something else, compute its len to decide\n            len (target) !== 0 ? target :\n            \n            // When all else fails, declare target as false\n            false\n        );\n    }\n    __all__.__t__ = __t__;\n\n    var bool = function (any) {     // Always truly returns a bool, rather than something truthy or falsy\n        return !!__t__ (any);\n    };\n    bool.__name__ = 'bool';         // So it can be used as a type with a name\n    __all__.bool = bool;\n\n    var float = function (any) {\n        if (any == 'inf') {\n            return Infinity;\n        }\n        else if (any == '-inf') {\n            return -Infinity;\n        }\n        else if (isNaN (parseFloat (any))) {    // Call to parseFloat needed to exclude '', ' ' etc.\n            if (any === false) {\n                return 0;\n            }\n            else if (any === true) {\n                return 1;\n            }\n            else {  // Needed e.g. in autoTester.check, so \"return any ? true : false\" won't do\n                throw ValueError (new Error ());\n            }\n        }\n        else {\n            return +any;\n        }\n    };\n    float.__name__ = 'float';\n    __all__.float = float;\n\n    var int = function (any) {\n        return float (any) | 0\n    };\n    int.__name__ = 'int';\n    __all__.int = int;\n\n    var py_typeof = function (anObject) {\n        var aType = typeof anObject;\n        if (aType == 'object') {    // Directly trying '__class__ in anObject' turns out to wreck anObject in Chrome if its a primitive\n            try {\n                return anObject.__class__;\n            }\n            catch (exception) {\n                return aType;\n            }\n        }\n        else {\n            return (    // Odly, the braces are required here\n                aType == 'boolean' ? bool :\n                aType == 'string' ? str :\n                aType == 'number' ? (anObject % 1 == 0 ? int : float) :\n                null\n            );\n        }\n    };\n    __all__.py_typeof = py_typeof;\n\n    var isinstance = function (anObject, classinfo) {\n        function isA (queryClass) {\n            if (queryClass == classinfo) {\n                return true;\n            }\n            for (var index = 0; index < queryClass.__bases__.length; index++) {\n                if (isA (queryClass.__bases__ [index], classinfo)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if (classinfo instanceof Array) {   // Assume in most cases it isn't, then making it recursive rather than two functions saves a call\n__pragma__ ('ifdef', '__esv6__')\n            for (let aClass of classinfo) {\n__pragma__ ('else')\n            for (var index = 0; index < classinfo.length; index++) {\n                var aClass = classinfo [index];\n__pragma__ ('endif')\n                if (isinstance (anObject, aClass)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        try {                   // Most frequent use case first\n            return '__class__' in anObject ? isA (anObject.__class__) : anObject instanceof classinfo;\n        }\n        catch (exception) {     // Using isinstance on primitives assumed rare\n            var aType = py_typeof (anObject);\n            return aType == classinfo || (aType == bool && classinfo == int);\n        }\n    };\n    __all__.isinstance = isinstance;\n\n    var callable = function (anObject) {\n        if ( typeof anObject == 'object' && '__call__' in anObject ) {\n            return true;\n        }\n        else {\n            return typeof anObject === 'function';\n        }\n    };\n    __all__.callable = callable;\n\n    // Repr function uses __repr__ method, then __str__, then toString\n    var repr = function (anObject) {\n        try {\n            return anObject.__repr__ ();\n        }\n        catch (exception) {\n            try {\n                return anObject.__str__ ();\n            }\n            catch (exception) { // anObject has no __repr__ and no __str__\n                try {\n                    if (anObject == null) {\n                        return 'None';\n                    }\n                    else if (anObject.constructor == Object) {\n                        var result = '{';\n                        var comma = false;\n                        for (var attrib in anObject) {\n                            if (!__specialattrib__ (attrib)) {\n                                if (attrib.isnumeric ()) {\n                                    var attribRepr = attrib;                // If key can be interpreted as numerical, we make it numerical\n                                }                                           // So we accept that '1' is misrepresented as 1\n                                else {\n                                    var attribRepr = '\\'' + attrib + '\\'';  // Alpha key in dict\n                                }\n\n                                if (comma) {\n                                    result += ', ';\n                                }\n                                else {\n                                    comma = true;\n                                }\n                                result += attribRepr + ': ' + repr (anObject [attrib]);\n                            }\n                        }\n                        result += '}';\n                        return result;\n                    }\n                    else {\n                        return typeof anObject == 'boolean' ? anObject.toString () .capitalize () : anObject.toString ();\n                    }\n                }\n                catch (exception) {\n                    return '<object of type: ' + typeof anObject + '>';\n                }\n            }\n        }\n    };\n    __all__.repr = repr;\n\n    // Char from Unicode or ASCII\n    var chr = function (charCode) {\n        return String.fromCharCode (charCode);\n    };\n    __all__.chr = chr;\n\n    // Unicode or ASCII from char\n    var ord = function (aChar) {\n        return aChar.charCodeAt (0);\n    };\n    __all__.ord = ord;\n\n    // Maximum of n numbers\n    var max = Math.max;\n    __all__.max = max;\n\n    // Minimum of n numbers\n    var min = Math.min;\n    __all__.min = min;\n\n    // Absolute value\n__pragma__ ('ifdef', '__complex__')\n    var abs = function (x) {\n        try {\n            return Math.abs (x);\n        }\n        catch (exception) {\n            return Math.sqrt (x.real * x.real + x.imag * x.imag);\n        }\n    };\n__pragma__ ('else')\n    var abs = Math.abs;\n    __all__.abs = abs;\n__pragma__ ('endif')\n\n    // Bankers rounding\n    var round = function (number, ndigits) {\n        if (ndigits) {\n            var scale = Math.pow (10, ndigits);\n            number *= scale;\n        }\n\n        var rounded = Math.round (number);\n        if (rounded - number == 0.5 && rounded % 2) {   // Has rounded up to odd, should have rounded down to even\n            rounded -= 1;\n        }\n\n        if (ndigits) {\n            rounded /= scale;\n        }\n\n        return rounded;\n    };\n    __all__.round = round;\n\n    // BEGIN unified iterator model\n\n    function __jsUsePyNext__ () {       // Add as 'next' method to make Python iterator JavaScript compatible\n        try {\n            var result = this.__next__ ();\n            return {value: result, done: false};\n        }\n        catch (exception) {\n            return {value: undefined, done: true};\n        }\n    }\n\n    function __pyUseJsNext__ () {       // Add as '__next__' method to make JavaScript iterator Python compatible\n        var result = this.next ();\n        if (result.done) {\n            throw StopIteration (new Error ());\n        }\n        else {\n            return result.value;\n        }\n    }\n\n    function py_iter (iterable) {                   // Alias for Python's iter function, produces a universal iterator / iterable, usable in Python and JavaScript\n        if (typeof iterable == 'string' || '__iter__' in iterable) {    // JavaScript Array or string or Python iterable (string has no 'in')\n            var result = iterable.__iter__ ();                          // Iterator has a __next__\n            result.next = __jsUsePyNext__;                              // Give it a next\n        }\n        else if ('selector' in iterable) {                              // Assume it's a JQuery iterator\n            var result = list (iterable) .__iter__ ();                  // Has a __next__\n            result.next = __jsUsePyNext__;                              // Give it a next\n        }\n        else if ('next' in iterable) {                                  // It's a JavaScript iterator already,  maybe a generator, has a next and may have a __next__\n            var result = iterable\n            if (! ('__next__' in result)) {                             // If there's no danger of recursion\n                result.__next__ = __pyUseJsNext__;                      // Give it a __next__\n            }\n        }\n        else if (Symbol.iterator in iterable) {                         // It's a JavaScript iterable such as a typed array, but not an iterator\n            var result = iterable [Symbol.iterator] ();                 // Has a next\n            result.__next__ = __pyUseJsNext__;                          // Give it a __next__\n        }\n        else {\n            throw IterableError (new Error ()); // No iterator at all\n        }\n        result [Symbol.iterator] = function () {return result;};\n        return result;\n    }\n\n    function py_next (iterator) {               // Called only in a Python context, could receive Python or JavaScript iterator\n        try {                                   // Primarily assume Python iterator, for max speed\n            var result = iterator.__next__ ();\n        }\n        catch (exception) {                     // JavaScript iterators are the exception here\n            var result = iterator.next ();\n            if (result.done) {\n                throw StopIteration (new Error ());\n            }\n            else {\n                return result.value;\n            }\n        }\n        if (result == undefined) {\n            throw StopIteration (new Error ());\n        }\n        else {\n            return result;\n        }\n    }\n\n    function __PyIterator__ (iterable) {\n        this.iterable = iterable;\n        this.index = 0;\n    }\n\n    __PyIterator__.prototype.__next__ = function () {\n        if (this.index < this.iterable.length) {\n            return this.iterable [this.index++];\n        }\n        else {\n            throw StopIteration (new Error ());\n        }\n    };\n\n    function __JsIterator__ (iterable) {\n        this.iterable = iterable;\n        this.index = 0;\n    }\n\n    __JsIterator__.prototype.next = function () {\n        if (this.index < this.iterable.py_keys.length) {\n            return {value: this.index++, done: false};\n        }\n        else {\n            return {value: undefined, done: true};\n        }\n    };\n\n    // END unified iterator model\n\n    // Reversed function for arrays\n    var py_reversed = function (iterable) {\n        iterable = iterable.slice ();\n        iterable.reverse ();\n        return iterable;\n    };\n    __all__.py_reversed = py_reversed;\n\n    // Zip method for arrays and strings\n    var zip = function () {\n        var args = [] .slice.call (arguments);\n        for (var i = 0; i < args.length; i++) {\n            if (typeof args [i] == 'string') {\n                args [i] = args [i] .split ('');\n            }\n            else if (!Array.isArray (args [i])) {\n                args [i] = Array.from (args [i]);\n            }\n        }\n        var shortest = args.length == 0 ? [] : args.reduce (    // Find shortest array in arguments\n            function (array0, array1) {\n                return array0.length < array1.length ? array0 : array1;\n            }\n        );\n        return shortest.map (                   // Map each element of shortest array\n            function (current, index) {         // To the result of this function\n                return args.map (               // Map each array in arguments\n                    function (current) {        // To the result of this function\n                        return current [index]; // Namely it's index't entry\n                    }\n                );\n            }\n        );\n    };\n    __all__.zip = zip;\n\n    // Range method, returning an array\n    function range (start, stop, step) {\n        if (stop == undefined) {\n            // one param defined\n            stop = start;\n            start = 0;\n        }\n        if (step == undefined) {\n            step = 1;\n        }\n        if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n            return [];\n        }\n        var result = [];\n        for (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n            result.push(i);\n        }\n        return result;\n    };\n    __all__.range = range;\n\n    // Any, all and sum\n\n__pragma__ ('ifdef', '__esv6__')\n    function any (iterable) {\n        for (let item of iterable) {\n            if (bool (item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function all (iterable) {\n        for (let item of iterable) {\n            if (! bool (item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sum (iterable) {\n        let result = 0;\n        for (let item of iterable) {\n            result += item;\n        }\n        return result;\n    }\n__pragma__ ('else')\n    function any (iterable) {\n        for (var index = 0; index < iterable.length; index++) {\n            if (bool (iterable [index])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function all (iterable) {\n        for (var index = 0; index < iterable.length; index++) {\n            if (! bool (iterable [index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sum (iterable) {\n        var result = 0;\n        for (var index = 0; index < iterable.length; index++) {\n            result += iterable [index];\n        }\n        return result;\n    }\n__pragma__ ('endif')\n\n    __all__.any = any;\n    __all__.all = all;\n    __all__.sum = sum;\n\n    // Enumerate method, returning a zipped list\n    function enumerate (iterable) {\n        return zip (range (len (iterable)), iterable);\n    }\n    __all__.enumerate = enumerate;\n\n    // Shallow and deepcopy\n\n    function copy (anObject) {\n        if (anObject == null || typeof anObject == \"object\") {\n            return anObject;\n        }\n        else {\n            var result = {};\n            for (var attrib in obj) {\n                if (anObject.hasOwnProperty (attrib)) {\n                    result [attrib] = anObject [attrib];\n                }\n            }\n            return result;\n        }\n    }\n    __all__.copy = copy;\n\n    function deepcopy (anObject) {\n        if (anObject == null || typeof anObject == \"object\") {\n            return anObject;\n        }\n        else {\n            var result = {};\n            for (var attrib in obj) {\n                if (anObject.hasOwnProperty (attrib)) {\n                    result [attrib] = deepcopy (anObject [attrib]);\n                }\n            }\n            return result;\n        }\n    }\n    __all__.deepcopy = deepcopy;\n\n    // List extensions to Array\n\n    function list (iterable) {                                      // All such creators should be callable without new\n__pragma__ ('ifdef', '__esv6__')\n        var instance = iterable ? Array.from (iterable) : [];\n__pragma__ ('else')\n        var instance = iterable ? [] .slice.apply (iterable) : [];  // Spread iterable, n.b. array.slice (), so array before dot\n__pragma__ ('endif')\n        // Sort is the normal JavaScript sort, Python sort is a non-member function\n        return instance;\n    }\n    __all__.list = list;\n    Array.prototype.__class__ = list;   // All arrays are lists (not only if constructed by the list ctor), unless constructed otherwise\n    list.__name__ = 'list';\n\n    /*\n    Array.from = function (iterator) { // !!! remove\n        result = [];\n        for (item of iterator) {\n            result.push (item);\n        }\n        return result;\n    }\n    */\n\n    Array.prototype.__iter__ = function () {return new __PyIterator__ (this);};\n\n    Array.prototype.__getslice__ = function (start, stop, step) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n        else if (stop > this.length) {\n            stop = this.length;\n        }\n\n        var result = list ([]);\n        for (var index = start; index < stop; index += step) {\n            result.push (this [index]);\n        }\n\n        return result;\n    };\n\n    Array.prototype.__setslice__ = function (start, stop, step, source) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n\n        if (step == null) { // Assign to 'ordinary' slice, replace subsequence\n            Array.prototype.splice.apply (this, [start, stop - start] .concat (source));\n        }\n        else {              // Assign to extended slice, replace designated items one by one\n            var sourceIndex = 0;\n            for (var targetIndex = start; targetIndex < stop; targetIndex += step) {\n                this [targetIndex] = source [sourceIndex++];\n            }\n        }\n    };\n\n    Array.prototype.__repr__ = function () {\n        if (this.__class__ == set && !this.length) {\n            return 'set()';\n        }\n\n        var result = !this.__class__ || this.__class__ == list ? '[' : this.__class__ == tuple ? '(' : '{';\n\n        for (var index = 0; index < this.length; index++) {\n            if (index) {\n                result += ', ';\n            }\n            result += repr (this [index]);\n        }\n\n        if (this.__class__ == tuple && this.length == 1) {\n            result += ',';\n        }\n\n        result += !this.__class__ || this.__class__ == list ? ']' : this.__class__ == tuple ? ')' : '}';;\n        return result;\n    };\n\n    Array.prototype.__str__ = Array.prototype.__repr__;\n\n    Array.prototype.append = function (element) {\n        this.push (element);\n    };\n\n    Array.prototype.clear = function () {\n        this.length = 0;\n    };\n\n    Array.prototype.extend = function (aList) {\n        this.push.apply (this, aList);\n    };\n\n    Array.prototype.insert = function (index, element) {\n        this.splice (index, 0, element);\n    };\n\n    Array.prototype.remove = function (element) {\n        var index = this.indexOf (element);\n        if (index == -1) {\n            throw ValueError (new Error ());\n        }\n        this.splice (index, 1);\n    };\n\n    Array.prototype.index = function (element) {\n        return this.indexOf (element);\n    };\n\n    Array.prototype.py_pop = function (index) {\n        if (index == undefined) {\n            return this.pop ();  // Remove last element\n        }\n        else {\n            return this.splice (index, 1) [0];\n        }\n    };\n\n    Array.prototype.py_sort = function () {\n        __sort__.apply  (null, [this].concat ([] .slice.apply (arguments)));    // Can't work directly with arguments\n        // Python params: (iterable, key = None, reverse = False)\n        // py_sort is called with the Transcrypt kwargs mechanism, and just passes the params on to __sort__\n        // __sort__ is def'ed with the Transcrypt kwargs mechanism\n    };\n\n    Array.prototype.__add__ = function (aList) {\n        return list (this.concat (aList));\n    };\n\n    Array.prototype.__mul__ = function (scalar) {\n        var result = this;\n        for (var i = 1; i < scalar; i++) {\n            result = result.concat (this);\n        }\n        return result;\n    };\n\n    Array.prototype.__rmul__ = Array.prototype.__mul__;\n\n    // Tuple extensions to Array\n\n    function tuple (iterable) {\n        var instance = iterable ? [] .slice.apply (iterable) : [];\n        instance.__class__ = tuple; // Not all arrays are tuples\n        return instance;\n    }\n    __all__.tuple = tuple;\n    tuple.__name__ = 'tuple';\n\n    // Set extensions to Array\n    // N.B. Since sets are unordered, set operations will occasionally alter the 'this' array by sorting it\n\n    function set (iterable) {\n        var instance = [];\n        if (iterable) {\n            for (var index = 0; index < iterable.length; index++) {\n                instance.add (iterable [index]);\n            }\n\n\n        }\n        instance.__class__ = set;   // Not all arrays are sets\n        return instance;\n    }\n    __all__.set = set;\n    set.__name__ = 'set';\n\n    Array.prototype.__bindexOf__ = function (element) { // Used to turn O (n^2) into O (n log n)\n    // Since sorting is lex, compare has to be lex. This also allows for mixed lists\n\n        element += '';\n\n        var mindex = 0;\n        var maxdex = this.length - 1;\n\n        while (mindex <= maxdex) {\n            var index = (mindex + maxdex) / 2 | 0;\n            var middle = this [index] + '';\n\n            if (middle < element) {\n                mindex = index + 1;\n            }\n            else if (middle > element) {\n                maxdex = index - 1;\n            }\n            else {\n                return index;\n            }\n        }\n\n        return -1;\n    };\n\n    Array.prototype.add = function (element) {\n        if (this.indexOf (element) == -1) { // Avoid duplicates in set\n            this.push (element);\n        }\n    };\n\n    Array.prototype.discard = function (element) {\n        var index = this.indexOf (element);\n        if (index != -1) {\n            this.splice (index, 1);\n        }\n    };\n\n    Array.prototype.isdisjoint = function (other) {\n        this.sort ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) != -1) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.issuperset = function (other) {\n        this.sort ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) == -1) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.issubset = function (other) {\n        return set (other.slice ()) .issuperset (this); // Sort copy of 'other', not 'other' itself, since it may be an ordered sequence\n    };\n\n    Array.prototype.union = function (other) {\n        var result = set (this.slice () .sort ());\n        for (var i = 0; i < other.length; i++) {\n            if (result.__bindexOf__ (other [i]) == -1) {\n                result.push (other [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.intersection = function (other) {\n        this.sort ();\n        var result = set ();\n        for (var i = 0; i < other.length; i++) {\n            if (this.__bindexOf__ (other [i]) != -1) {\n                result.push (other [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.difference = function (other) {\n        var sother = set (other.slice () .sort ());\n        var result = set ();\n        for (var i = 0; i < this.length; i++) {\n            if (sother.__bindexOf__ (this [i]) == -1) {\n                result.push (this [i]);\n            }\n        }\n        return result;\n    };\n\n    Array.prototype.symmetric_difference = function (other) {\n        return this.union (other) .difference (this.intersection (other));\n    };\n\n    Array.prototype.py_update = function () {   // O (n)\n        var updated = [] .concat.apply (this.slice (), arguments) .sort ();\n        this.clear ();\n        for (var i = 0; i < updated.length; i++) {\n            if (updated [i] != updated [i - 1]) {\n                this.push (updated [i]);\n            }\n        }\n    };\n\n    Array.prototype.__eq__ = function (other) { // Also used for list\n        if (this.length != other.length) {\n            return false;\n        }\n        if (this.__class__ == set) {\n            this.sort ();\n            other.sort ();\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this [i] != other [i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    Array.prototype.__ne__ = function (other) { // Also used for list\n        return !this.__eq__ (other);\n    };\n\n    Array.prototype.__le__ = function (other) {\n        return this.issubset (other);\n    };\n\n    Array.prototype.__ge__ = function (other) {\n        return this.issuperset (other);\n    };\n\n    Array.prototype.__lt__ = function (other) {\n        return this.issubset (other) && !this.issuperset (other);\n    };\n\n    Array.prototype.__gt__ = function (other) {\n        return this.issuperset (other) && !this.issubset (other);\n    };\n\n    // String extensions\n\n    function str (stringable) {\n        try {\n            return stringable.__str__ ();\n        }\n        catch (exception) {\n            try {\n                return repr (stringable);\n            }\n            catch (exception) {\n                return String (stringable); // No new, so no permanent String object but a primitive in a temporary 'just in time' wrapper\n            }\n        }\n    };\n    __all__.str = str;\n\n    String.prototype.__class__ = str;   // All strings are str\n    str.__name__ = 'str';\n\n    String.prototype.__iter__ = function () {new __PyIterator__ (this);};\n\n    String.prototype.__repr__ = function () {\n        return (this.indexOf ('\\'') == -1 ? '\\'' + this + '\\'' : '\"' + this + '\"') .py_replace ('\\t', '\\\\t') .py_replace ('\\n', '\\\\n');\n    };\n\n    String.prototype.__str__ = function () {\n        return this;\n    };\n\n    String.prototype.capitalize = function () {\n        return this.charAt (0).toUpperCase () + this.slice (1);\n    };\n\n    String.prototype.endswith = function (suffix) {\n        return suffix == '' || this.slice (-suffix.length) == suffix;\n    };\n\n    String.prototype.find  = function (sub, start) {\n        return this.indexOf (sub, start);\n    };\n\n    String.prototype.__getslice__ = function (start, stop, step) {\n        if (start < 0) {\n            start = this.length + start;\n        }\n\n        if (stop == null) {\n            stop = this.length;\n        }\n        else if (stop < 0) {\n            stop = this.length + stop;\n        }\n\n        var result = '';\n        if (step == 1) {\n            result = this.substring (start, stop);\n        }\n        else {\n            for (var index = start; index < stop; index += step) {\n                result = result.concat (this.charAt(index));\n            }\n        }\n        return result;\n    }\n\n    // Since it's worthwhile for the 'format' function to be able to deal with *args, it is defined as a property\n    // __get__ will produce a bound function if there's something before the dot\n    // Since a call using *args is compiled to e.g. <object>.<function>.apply (null, args), the function has to be bound already\n    // Otherwise it will never be, because of the null argument\n    // Using 'this' rather than 'null' contradicts the requirement to be able to pass bound functions around\n    // The object 'before the dot' won't be available at call time in that case, unless implicitly via the function bound to it\n    // While for Python methods this mechanism is generated by the compiler, for JavaScript methods it has to be provided manually\n    // Call memoizing is unattractive here, since every string would then have to hold a reference to a bound format method\n    __setProperty__ (String.prototype, 'format', {\n        get: function () {return __get__ (this, function (self) {\n            var args = tuple ([] .slice.apply (arguments).slice (1));\n            var autoIndex = 0;\n            return self.replace (/\\{(\\w*)\\}/g, function (match, key) {\n                if (key == '') {\n                    key = autoIndex++;\n                }\n                if (key == +key) {  // So key is numerical\n                    return args [key] == undefined ? match : str (args [key]);\n                }\n                else {              // Key is a string\n                    for (var index = 0; index < args.length; index++) {\n                        // Find first 'dict' that has that key and the right field\n                        if (typeof args [index] == 'object' && args [index][key] != undefined) {\n                            return str (args [index][key]); // Return that field field\n                        }\n                    }\n                    return match;\n                }\n            });\n        });},\n        enumerable: true\n    });\n\n    String.prototype.isalnum = function () {\n        return /^[0-9a-zA-Z]{1,}$/.test(this)\n    }\n\n    String.prototype.isalpha = function () {\n        return /^[a-zA-Z]{1,}$/.test(this)\n    }\n\n    String.prototype.isdecimal = function () {\n        return /^[0-9]{1,}$/.test(this)\n    }\n\n    String.prototype.isdigit = function () {\n        return this.isdecimal()\n    }\n\n    String.prototype.islower = function () {\n        return /^[a-z]{1,}$/.test(this)\n    }\n\n    String.prototype.isupper = function () {\n        return /^[A-Z]{1,}$/.test(this)\n    }\n\n    String.prototype.isspace = function () {\n        return /^[\\s]{1,}$/.test(this)\n    }\n\n    String.prototype.isnumeric = function () {\n        return !isNaN (parseFloat (this)) && isFinite (this);\n    };\n\n    String.prototype.join = function (strings) {\n__pragma__ ('ifdef', '__esv6__')\n        strings = Array.from (strings); // Much faster than iterating through strings char by char\n__pragma__ ('endif')\n        return strings.join (this);\n    };\n\n    String.prototype.lower = function () {\n        return this.toLowerCase ();\n    };\n\n    String.prototype.py_replace = function (old, aNew, maxreplace) {\n        return this.split (old, maxreplace) .join (aNew);\n    };\n\n    String.prototype.lstrip = function () {\n        return this.replace (/^\\s*/g, '');\n    };\n\n    String.prototype.rfind = function (sub, start) {\n        return this.lastIndexOf (sub, start);\n    };\n\n    String.prototype.rsplit = function (sep, maxsplit) {    // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n        if (sep == undefined || sep == null) {\n            sep = /\\s+/;\n            var stripped = this.strip ();\n        }\n        else {\n            var stripped = this;\n        }\n\n        if (maxsplit == undefined || maxsplit == -1) {\n            return stripped.split (sep);\n        }\n        else {\n            var result = stripped.split (sep);\n            if (maxsplit < result.length) {\n                var maxrsplit = result.length - maxsplit;\n                return [result.slice (0, maxrsplit) .join (sep)] .concat (result.slice (maxrsplit));\n            }\n            else {\n                return result;\n            }\n        }\n    };\n\n    String.prototype.rstrip = function () {\n        return this.replace (/\\s*$/g, '');\n    };\n\n    String.prototype.py_split = function (sep, maxsplit) {  // Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n        if (sep == undefined || sep == null) {\n            sep = /\\s+/;\n            var stripped = this.strip ();\n        }\n        else {\n            var stripped = this;\n        }\n\n        if (maxsplit == undefined || maxsplit == -1) {\n            return stripped.split (sep);\n        }\n        else {\n            var result = stripped.split (sep);\n            if (maxsplit < result.length) {\n                return result.slice (0, maxsplit).concat ([result.slice (maxsplit).join (sep)]);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n\n    String.prototype.startswith = function (prefix) {\n        return this.indexOf (prefix) == 0;\n    };\n\n    String.prototype.strip = function () {\n        return this.trim ();\n    };\n\n    String.prototype.upper = function () {\n        return this.toUpperCase ();\n    };\n\n    String.prototype.__mul__ = function (scalar) {\n        var result = this;\n        for (var i = 1; i < scalar; i++) {\n            result = result + this;\n        }\n        return result;\n    };\n\n    String.prototype.__rmul__ = String.prototype.__mul__;\n\n    // Dict extensions to object\n\n    function __keys__ () {\n        var keys = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                keys.push (attrib);\n            }\n        }\n        return keys;\n    }\n\n    function __items__ () {\n        var items = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                items.push ([attrib, this [attrib]]);\n            }\n        }\n        return items;\n    }\n\n    function __del__ (key) {\n        delete this [key];\n    }\n\n    function __clear__ () {\n        for (var attrib in this) {\n            delete this [attrib];\n        }\n    }\n\n    function __getdefault__ (aKey, aDefault) {  // Each Python object already has a function called __get__, so we call this one __getdefault__\n        var result = this [aKey];\n        return result == undefined ? (aDefault == undefined ? null : aDefault) : result;\n    }\n\n    function __setdefault__ (aKey, aDefault) {\n        var result = this [aKey];\n        if (result != undefined) {\n            return result;\n        }\n        var val = aDefault == undefined ? null : aDefault;\n        this [aKey] = val;\n        return val;\n    }\n\n    function __pop__ (aKey, aDefault) {\n        var result = this [aKey];\n        if (result != undefined) {\n            delete this [aKey];\n            return result;\n        } else {\n            // Identify check because user could pass None\n            if ( aDefault === undefined ) {\n                throw KeyError (aKey, new Error());\n            }\n        }\n        return aDefault;\n    }\n    \n    function __popitem__ () {\n        var aKey = Object.keys (this) [0];\n        if (aKey == null) {\n            throw KeyError (aKey, new Error ());\n        }\n        var result = tuple ([aKey, this [aKey]]);\n        delete this [aKey];\n        return result;\n    }\n    \n    function __update__ (aDict) {\n        for (var aKey in aDict) {\n            this [aKey] = aDict [aKey];\n        }\n    }\n    \n    function __values__ () {\n        var values = [];\n        for (var attrib in this) {\n            if (!__specialattrib__ (attrib)) {\n                values.push (this [attrib]);\n            }\n        }\n        return values;\n\n    }\n    \n    function __dgetitem__ (aKey) {\n        return this [aKey];\n    }\n    \n    function __dsetitem__ (aKey, aValue) {\n        this [aKey] = aValue;\n    }\n\n    function dict (objectOrPairs) {\n        var instance = {};\n        if (!objectOrPairs || objectOrPairs instanceof Array) { // It's undefined or an array of pairs\n            if (objectOrPairs) {\n                for (var index = 0; index < objectOrPairs.length; index++) {\n                    var pair = objectOrPairs [index];\n                    if ( !(pair instanceof Array) || pair.length != 2) {\n                        throw ValueError(\n                            \"dict update sequence element #\" + index +\n                            \" has length \" + pair.length +\n                            \"; 2 is required\", new Error());\n                    }\n                    var key = pair [0];\n                    var val = pair [1];\n                    if (!(objectOrPairs instanceof Array) && objectOrPairs instanceof Object) {\n                         // User can potentially pass in an object\n                         // that has a hierarchy of objects. This\n                         // checks to make sure that these objects\n                         // get converted to dict objects instead of\n                         // leaving them as js objects.\n                         \n                         if (!isinstance (objectOrPairs, dict)) {\n                             val = dict (val);\n                         }\n                    }\n                    instance [key] = val;\n                }\n            }\n        }\n        else {\n            if (isinstance (objectOrPairs, dict)) {\n                // Passed object is a dict already so we need to be a little careful\n                // N.B. - this is a shallow copy per python std - so\n                // it is assumed that children have already become\n                // python objects at some point.\n                \n                var aKeys = objectOrPairs.py_keys ();\n                for (var index = 0; index < aKeys.length; index++ ) {\n                    var key = aKeys [index];\n                    instance [key] = objectOrPairs [key];\n                }\n            } else if (objectOrPairs instanceof Object) {\n                // Passed object is a JavaScript object but not yet a dict, don't copy it\n                instance = objectOrPairs;\n            } else {\n                // We have already covered Array so this indicates\n                // that the passed object is not a js object - i.e.\n                // it is an int or a string, which is invalid.\n                \n                throw ValueError (\"Invalid type of object for dict creation\", new Error ());\n            }\n        }\n\n        // Trancrypt interprets e.g. {aKey: 'aValue'} as a Python dict literal rather than a JavaScript object literal\n        // So dict literals rather than bare Object literals will be passed to JavaScript libraries\n        // Some JavaScript libraries call all enumerable callable properties of an object that's passed to them\n        // So the properties of a dict should be non-enumerable\n        __setProperty__ (instance, '__class__', {value: dict, enumerable: false, writable: true});\n        __setProperty__ (instance, 'py_keys', {value: __keys__, enumerable: false});\n        __setProperty__ (instance, '__iter__', {value: function () {new __PyIterator__ (this.py_keys ());}, enumerable: false});\n        __setProperty__ (instance, Symbol.iterator, {value: function () {new __JsIterator__ (this.py_keys ());}, enumerable: false});\n        __setProperty__ (instance, 'py_items', {value: __items__, enumerable: false});\n        __setProperty__ (instance, 'py_del', {value: __del__, enumerable: false});\n        __setProperty__ (instance, 'py_clear', {value: __clear__, enumerable: false});\n        __setProperty__ (instance, 'py_get', {value: __getdefault__, enumerable: false});\n        __setProperty__ (instance, 'py_setdefault', {value: __setdefault__, enumerable: false});\n        __setProperty__ (instance, 'py_pop', {value: __pop__, enumerable: false});\n        __setProperty__ (instance, 'py_popitem', {value: __popitem__, enumerable: false});\n        __setProperty__ (instance, 'py_update', {value: __update__, enumerable: false});\n        __setProperty__ (instance, 'py_values', {value: __values__, enumerable: false});\n        __setProperty__ (instance, '__getitem__', {value: __dgetitem__, enumerable: false});    // Needed since compound keys necessarily\n        __setProperty__ (instance, '__setitem__', {value: __dsetitem__, enumerable: false});    // trigger overloading to deal with slices\n        return instance;\n    }\n\n    __all__.dict = dict;\n    dict.__name__ = 'dict';\n    \n    // Docstring setter\n\n    function __setdoc__ (docString) {\n        this.__doc__ = docString;\n        return this;\n    }\n\n    // Python classes, methods and functions are all translated to JavaScript functions\n    __setProperty__ (Function.prototype, '__setdoc__', {value: __setdoc__, enumerable: false});\n\n    // General operator overloading, only the ones that make most sense in matrix and complex operations\n\n    var __neg__ = function (a) {\n        if (typeof a == 'object' && '__neg__' in a) {\n            return a.__neg__ ();\n        }\n        else {\n            return -a;\n        }\n    };\n    __all__.__neg__ = __neg__;\n\n    var __matmul__ = function (a, b) {\n        return a.__matmul__ (b);\n    };\n    __all__.__matmul__ = __matmul__;\n\n    var __pow__ = function (a, b) {\n        if (typeof a == 'object' && '__pow__' in a) {\n            return a.__pow__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rpow__ (a);\n        }\n        else {\n            return Math.pow (a, b);\n        }\n    };\n    __all__.pow = __pow__;\n\n    var __jsmod__ = function (a, b) {\n        if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return a % b;\n        }\n    };\n    __all__.__jsmod__ = __jsmod__;\n    \n    var __mod__ = function (a, b) {\n        if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return ((a % b) + b) % b;\n        }\n    };\n    __all__.mod = __mod__;\n\n    // Overloaded binary arithmetic\n    \n    var __mul__ = function (a, b) {\n        if (typeof a == 'object' && '__mul__' in a) {\n            return a.__mul__ (b);\n        }\n        else if (typeof b == 'object' && '__rmul__' in b) {\n            return b.__rmul__ (a);\n        }\n        else if (typeof a == 'string') {\n            return a.__mul__ (b);\n        }\n        else if (typeof b == 'string') {\n            return b.__rmul__ (a);\n        }\n        else {\n            return a * b;\n        }\n    };\n    __all__.__mul__ = __mul__;\n\n    var __truediv__ = function (a, b) {\n        if (typeof a == 'object' && '__truediv__' in a) {\n            return a.__truediv__ (b);\n        }\n        else if (typeof b == 'object' && '__rtruediv__' in b) {\n            return b.__rtruediv__ (a);\n        }\n        else if (typeof a == 'object' && '__div__' in a) {\n            return a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return b.__rdiv__ (a);\n        }\n        else {\n            return a / b;\n        }\n    };\n    __all__.__truediv__ = __truediv__;\n\n    var __floordiv__ = function (a, b) {\n        if (typeof a == 'object' && '__floordiv__' in a) {\n            return a.__floordiv__ (b);\n        }\n        else if (typeof b == 'object' && '__rfloordiv__' in b) {\n            return b.__rfloordiv__ (a);\n        }\n        else if (typeof a == 'object' && '__div__' in a) {\n            return a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return b.__rdiv__ (a);\n        }\n        else {\n            return Math.floor (a / b);\n        }\n    };\n    __all__.__floordiv__ = __floordiv__;\n\n    var __add__ = function (a, b) {\n        if (typeof a == 'object' && '__add__' in a) {\n            return a.__add__ (b);\n        }\n        else if (typeof b == 'object' && '__radd__' in b) {\n            return b.__radd__ (a);\n        }\n        else {\n            return a + b;\n        }\n    };\n    __all__.__add__ = __add__;\n\n    var __sub__ = function (a, b) {\n        if (typeof a == 'object' && '__sub__' in a) {\n            return a.__sub__ (b);\n        }\n        else if (typeof b == 'object' && '__rsub__' in b) {\n            return b.__rsub__ (a);\n        }\n        else {\n            return a - b;\n        }\n    };\n    __all__.__sub__ = __sub__;\n\n    // Overloaded binary bitwise\n    \n    var __lshift__ = function (a, b) {\n        if (typeof a == 'object' && '__lshift__' in a) {\n            return a.__lshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rlshift__' in b) {\n            return b.__rlshift__ (a);\n        }\n        else {\n            return a << b;\n        }\n    };\n    __all__.__lshift__ = __lshift__;\n\n    var __rshift__ = function (a, b) {\n        if (typeof a == 'object' && '__rshift__' in a) {\n            return a.__rshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rrshift__' in b) {\n            return b.__rrshift__ (a);\n        }\n        else {\n            return a >> b;\n        }\n    };\n    __all__.__rshift__ = __rshift__;\n\n    var __or__ = function (a, b) {\n        if (typeof a == 'object' && '__or__' in a) {\n            return a.__or__ (b);\n        }\n        else if (typeof b == 'object' && '__ror__' in b) {\n            return b.__ror__ (a);\n        }\n        else {\n            return a | b;\n        }\n    };\n    __all__.__or__ = __or__;\n\n    var __xor__ = function (a, b) {\n        if (typeof a == 'object' && '__xor__' in a) {\n            return a.__xor__ (b);\n        }\n        else if (typeof b == 'object' && '__rxor__' in b) {\n            return b.__rxor__ (a);\n        }\n        else {\n            return a ^ b;\n        }\n    };\n    __all__.__xor__ = __xor__;\n\n    var __and__ = function (a, b) {\n        if (typeof a == 'object' && '__and__' in a) {\n            return a.__and__ (b);\n        }\n        else if (typeof b == 'object' && '__rand__' in b) {\n            return b.__rand__ (a);\n        }\n        else {\n            return a & b;\n        }\n    };\n    __all__.__and__ = __and__;\n\n    // Overloaded binary compare\n    \n    var __eq__ = function (a, b) {\n        if (typeof a == 'object' && '__eq__' in a) {\n            return a.__eq__ (b);\n        }\n        else {\n            return a == b;\n        }\n    };\n    __all__.__eq__ = __eq__;\n\n    var __ne__ = function (a, b) {\n        if (typeof a == 'object' && '__ne__' in a) {\n            return a.__ne__ (b);\n        }\n        else {\n            return a != b\n        }\n    };\n    __all__.__ne__ = __ne__;\n\n    var __lt__ = function (a, b) {\n        if (typeof a == 'object' && '__lt__' in a) {\n            return a.__lt__ (b);\n        }\n        else {\n            return a < b;\n        }\n    };\n    __all__.__lt__ = __lt__;\n\n    var __le__ = function (a, b) {\n        if (typeof a == 'object' && '__le__' in a) {\n            return a.__le__ (b);\n        }\n        else {\n            return a <= b;\n        }\n    };\n    __all__.__le__ = __le__;\n\n    var __gt__ = function (a, b) {\n        if (typeof a == 'object' && '__gt__' in a) {\n            return a.__gt__ (b);\n        }\n        else {\n            return a > b;\n        }\n    };\n    __all__.__gt__ = __gt__;\n\n    var __ge__ = function (a, b) {\n        if (typeof a == 'object' && '__ge__' in a) {\n            return a.__ge__ (b);\n        }\n        else {\n            return a >= b;\n        }\n    };\n    __all__.__ge__ = __ge__;\n    \n    // Overloaded augmented general\n    \n    var __imatmul__ = function (a, b) {\n        if ('__imatmul__' in a) {\n            return a.__imatmul__ (b);\n        }\n        else {\n            return a.__matmul__ (b);\n        }\n    };\n    __all__.__imatmul__ = __imatmul__;\n\n    var __ipow__ = function (a, b) {\n        if (typeof a == 'object' && '__pow__' in a) {\n            return a.__ipow__ (b);\n        }\n        else if (typeof a == 'object' && '__ipow__' in a) {\n            return a.__pow__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rpow__ (a);\n        }\n        else {\n            return Math.pow (a, b);\n        }\n    };\n    __all__.ipow = __ipow__;\n\n    var __ijsmod__ = function (a, b) {\n        if (typeof a == 'object' && '__imod__' in a) {\n            return a.__ismod__ (b);\n        }\n        else if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return a % b;\n        }\n    };\n    __all__.ijsmod__ = __ijsmod__;\n    \n    var __imod__ = function (a, b) {\n        if (typeof a == 'object' && '__imod__' in a) {\n            return a.__imod__ (b);\n        }\n        else if (typeof a == 'object' && '__mod__' in a) {\n            return a.__mod__ (b);\n        }\n        else if (typeof b == 'object' && '__rpow__' in b) {\n            return b.__rmod__ (a);\n        }\n        else {\n            return ((a % b) + b) % b;\n        }\n    };\n    __all__.imod = __imod__;\n    \n    // Overloaded augmented arithmetic\n    \n    var __imul__ = function (a, b) {\n        if (typeof a == 'object' && '__imul__' in a) {\n            return a.__imul__ (b);\n        }\n        else if (typeof a == 'object' && '__mul__' in a) {\n            return a = a.__mul__ (b);\n        }\n        else if (typeof b == 'object' && '__rmul__' in b) {\n            return a = b.__rmul__ (a);\n        }\n        else if (typeof a == 'string') {\n            return a = a.__mul__ (b);\n        }\n        else if (typeof b == 'string') {\n            return a = b.__rmul__ (a);\n        }\n        else {\n            return a *= b;\n        }\n    };\n    __all__.__imul__ = __imul__;\n\n    var __idiv__ = function (a, b) {\n        if (typeof a == 'object' && '__idiv__' in a) {\n            return a.__idiv__ (b);\n        }\n        else if (typeof a == 'object' && '__div__' in a) {\n            return a = a.__div__ (b);\n        }\n        else if (typeof b == 'object' && '__rdiv__' in b) {\n            return a = b.__rdiv__ (a);\n        }\n        else {\n            return a /= b;\n        }\n    };\n    __all__.__idiv__ = __idiv__;\n\n    var __iadd__ = function (a, b) {\n        if (typeof a == 'object' && '__iadd__' in a) {\n            return a.__iadd__ (b);\n        }\n        else if (typeof a == 'object' && '__add__' in a) {\n            return a = a.__add__ (b);\n        }\n        else if (typeof b == 'object' && '__radd__' in b) {\n            return a = b.__radd__ (a);\n        }\n        else {\n            return a += b;\n        }\n    };\n    __all__.__iadd__ = __iadd__;\n\n    var __isub__ = function (a, b) {\n        if (typeof a == 'object' && '__isub__' in a) {\n            return a.__isub__ (b);\n        }\n        else if (typeof a == 'object' && '__sub__' in a) {\n            return a = a.__sub__ (b);\n        }\n        else if (typeof b == 'object' && '__rsub__' in b) {\n            return a = b.__rsub__ (a);\n        }\n        else {\n            return a -= b;\n        }\n    };\n    __all__.__isub__ = __isub__;\n\n    // Overloaded augmented bitwise\n    \n    var __ilshift__ = function (a, b) {\n        if (typeof a == 'object' && '__ilshift__' in a) {\n            return a.__ilshift__ (b);\n        }\n        else if (typeof a == 'object' && '__lshift__' in a) {\n            return a = a.__lshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rlshift__' in b) {\n            return a = b.__rlshift__ (a);\n        }\n        else {\n            return a <<= b;\n        }\n    };\n    __all__.__ilshift__ = __ilshift__;\n\n    var __irshift__ = function (a, b) {\n        if (typeof a == 'object' && '__irshift__' in a) {\n            return a.__irshift__ (b);\n        }\n        else if (typeof a == 'object' && '__rshift__' in a) {\n            return a = a.__rshift__ (b);\n        }\n        else if (typeof b == 'object' && '__rrshift__' in b) {\n            return a = b.__rrshift__ (a);\n        }\n        else {\n            return a >>= b;\n        }\n    };\n    __all__.__irshift__ = __irshift__;\n\n    var __ior__ = function (a, b) {\n        if (typeof a == 'object' && '__ior__' in a) {\n            return a.__ior__ (b);\n        }\n        else if (typeof a == 'object' && '__or__' in a) {\n            return a = a.__or__ (b);\n        }\n        else if (typeof b == 'object' && '__ror__' in b) {\n            return a = b.__ror__ (a);\n        }\n        else {\n            return a |= b;\n        }\n    };\n    __all__.__ior__ = __ior__;\n\n    var __ixor__ = function (a, b) {\n        if (typeof a == 'object' && '__ixor__' in a) {\n            return a.__ixor__ (b);\n        }\n        else if (typeof a == 'object' && '__xor__' in a) {\n            return a = a.__xor__ (b);\n        }\n        else if (typeof b == 'object' && '__rxor__' in b) {\n            return a = b.__rxor__ (a);\n        }\n        else {\n            return a ^= b;\n        }\n    };\n    __all__.__ixor__ = __ixor__;\n\n    var __iand__ = function (a, b) {\n        if (typeof a == 'object' && '__iand__' in a) {\n            return a.__iand__ (b);\n        }\n        else if (typeof a == 'object' && '__and__' in a) {\n            return a = a.__and__ (b);\n        }\n        else if (typeof b == 'object' && '__rand__' in b) {\n            return a = b.__rand__ (a);\n        }\n        else {\n            return a &= b;\n        }\n    };\n    __all__.__iand__ = __iand__;\n    \n    // Indices and slices\n\n    var __getitem__ = function (container, key) {                           // Slice c.q. index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__getitem__' in container) {\n            return container.__getitem__ (key);                             // Overloaded on container\n        }\n        else {\n            return container [key];                                         // Container must support bare JavaScript brackets\n        }\n    };\n    __all__.__getitem__ = __getitem__;\n\n    var __setitem__ = function (container, key, value) {                    // Slice c.q. index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__setitem__' in container) {\n            container.__setitem__ (key, value);                             // Overloaded on container\n        }\n        else {\n            container [key] = value;                                        // Container must support bare JavaScript brackets\n        }\n    };\n    __all__.__setitem__ = __setitem__;\n\n    var __getslice__ = function (container, lower, upper, step) {           // Slice only, no index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__getitem__' in container) {\n            return container.__getitem__ ([lower, upper, step]);            // Container supports overloaded slicing c.q. indexing\n        }\n        else {\n            return container.__getslice__ (lower, upper, step);             // Container only supports slicing injected natively in prototype\n        }\n    };\n    __all__.__getslice__ = __getslice__;\n\n    var __setslice__ = function (container, lower, upper, step, value) {    // Slice, no index, direct generated call to runtime switch\n        if (typeof container == 'object' && '__setitem__' in container) {\n            container.__setitem__ ([lower, upper, step], value);            // Container supports overloaded slicing c.q. indexing\n        }\n        else {\n            container.__setslice__ (lower, upper, step, value);             // Container only supports slicing injected natively in prototype\n        }\n    };\n    __all__.__setslice__ = __setslice__;\n",
		"import pyreact\nimport random\n\n\n# Note that using a string for JSX is not optimal - the next step is to have\n# Transcrypt to convert the jsx at transpile time, probably through some type \n# of plugin mechanism.\n\ndef randcolor():\n    return '#{}'.format(''.join([ random.choice('0123456789abcdef') for i in range(6) ]))\n\n\n############################################\n###  A digital clock\n\nclass Clock(pyreact.Component):\n    def __init__(self, props):\n        # very important to call super\n        super().__init__(props)\n        \n        # state dictionary, just like in JS\n        self.state = {\n            'randcolor': randcolor(),\n        }\n    \n    \n    def render(self):\n        # when using .jsx, pyreact places `self` and all Component classes in scope automatically\n        # extra variables, like `color` below, go in the context dictionary or as keyword args.\n        # (yes, I realize {self.state.randcolor} could have been in the jsx - just doing an example :)\n        return self.jsx('''\n            <button className=\"clock\" style={style} onClick={self.on_click}>\n                <ClockNumber key=\"hour\" value={self.props.hour} />\n                :\n                <ClockNumber key=\"minute\" value={self.props.minute} />\n                :\n                <ClockNumber key=\"second\" value={self.props.second} />\n            </button>\n        ''', \n            # as a keyword arg:\n            style={ 'color': self.state.randcolor }\n        )\n        \n        \n    def on_click(self, evt):\n        self.setState({\n            'randcolor': randcolor(),\n        })\n\n\n\n##############################################\n###  A number on a clock\n\nclass ClockNumber(pyreact.Component):\n    # no need for __init__ because not using .state\n\n    def render(self):\n        # example of returning a string directly\n        return str(self.props.value).padStart(2, '0')\n\n",
		"##\n##  Author: Conan Albrecht <doconix@gmail.com>\n##  License: Apache Open Source\n##  November, 2017\n##\n__pragma__('kwargs')\nimport re\n\n# match our version number against main.js\n__pyreact_version__ = '1.0.0'\nif not window['PyReact']:\n    console.warn('The PyReact JS object is not available. Have you loaded the <script> element for pyreact-bundle.js?')\nelif window['PyReact'].__pyreact_version__ != __pyreact_version__:\n    console.warn('Version mismatch in PyReact: pyreact-bundle.js is {} while pyreact.py is {}'.format(\n        window['PyReact'].__pyreact_version__,\n        __pyreact_version__,\n    ))\n\n\n###################################################\n###   React Components\n        \n# this is a bit of a hack, and I'm happy to have someone do it a better way.\n# when pyreact.Component classes are created, we register a reference here.\n# this allows us to put components into the context so the JSX compiler can\n# find them.  Otherwise the comverter would not be able to resolve names like\n# <MyCustomComponent />.\nregistered_components = {}        \n        \nclass ComponentMeta(type):        \n    def __new__ (meta, name, bases, attribs):\n        cls = type.__new__ (meta, name, bases, attribs)\n        registered_components[name] = cls\n        # override the default name='cls' property to make error messages and debugging more meaningful\n        # if transcrypt makes this change, we can take this part out\n        descrip = Object.getOwnPropertyDescriptor(cls, 'name');\n        descrip.value = name\n        Object.defineProperty(cls, 'name', descrip);\n        return cls\n        \n        \nclass AbstractComponent(object, metaclass=ComponentMeta):\n    '''Superclass for React Components.  Use Component or PureComponent below.'''\n    def __init__(self, props):\n        object.__init__(self)\n        \n        \n    def render(self):\n        return 'Subclass should override render()'\n    \n\n    def element(self, elem, props, *children):\n        '''Creates React elements using Component class and properties dictionary'''\n        return React.createElement(elem, props, *children)\n        \n        \n    def jsx(self, jsx_st, context=None, **kw_context):\n        '''\n        Creates React elements using JSX strings.  \"self\" and all\n        Component classes are automatically placed in the context.\n        Any additional {variables} referenced in the jsx should be\n        sent in the context dictionary.\n        \n        Note that any logic in the jsx must be done in JS right now because\n        Transcrypt doesn't transpile strings in the source code.  For example,\n        use the JS ternary operator for ifs, not the Python one.\n        '''\n        # this is not optimal because we're converting the JSX string every time\n        # render is called. Normal react transpiles to normal JS at build time.\n        # it's still enough fast and scales fine (since client browsers do this),\n        # but we should somehow plug it into transcrypt transpiler.\n        jsx_context = {}\n        jsx_context.update(registered_components)\n        jsx_context['self'] = self\n        if context is not None:\n            jsx_context.update(context)\n        if len(kw_context) > 0:\n            jsx_context.update(kw_context)\n        try:\n            return PyReact.jsx(jsx_st, jsx_context)\n        except ReferenceError as e:\n            msg = 'jsx references an unknown context name: {}'.format(e.message)\n            console.error(msg, e)\n            return msg\n        \n        \nclass Component(AbstractComponent, React.Component.prototype):\n    '''Superclass for React Components.  PyReact version of React.Component'''\n    def __init__(self, props):\n        AbstractComponent.__init__(self)\n        React.Component.apply(self, [ props ])\n        \n        \nclass PureComponent(AbstractComponent, React.PureComponent.prototype):\n    '''Superclass for React Components.  PyReact version of React.PureComponent'''\n    def __init__(self, props):\n        AbstractComponent.__init__(self)\n        React.PureComponent.apply(self, [ props ])\n        \n        \n    ",
		"# Mersenne-Twister algorithm\n\n_array = [0 for i in range (624)]\n_index = 0\n_bitmask1 = (2 ** 32) - 1\n_bitmask2 = 2 ** 31\n_bitmask3 = (2 ** 31) - 1\n\ndef _fill_array():\n    global _array\n    for i in range (624):\n        y = (_array [i] & _bitmask2) + (_array [(i + 1) % 624] & _bitmask3)\n        _array [i] = _array [(i + 397) % 624] ^ (y >> 1)\n        if y % 2 != 0:\n            _array[i] ^= 2567483615\n            \ndef _random_integer ():\n    global _index\n    global _array\n    if _index == 0:\n        _fill_array ()\n    y = _array [_index]\n    y ^= y >> 11\n    y ^= (y << 7) & 2636928640\n    y ^= (y << 15) & 4022730752\n    y ^= y >> 18\n\n    _index = (_index + 1) % 624\n    return y\n\ndef seed (x = int (_bitmask3 * Math.random ())):\n    global _array\n    global _bitmask1\n    _array [0] = x\n    for i in  range (1, 624):\n        _array [i] = ((1812433253 * _array [i - 1]) ^ ((_array [i - 1] >> 30) + i)) & _bitmask1\n\ndef randint (a, b):\n    return a + _random_integer () % (b - a + 1)\n\ndef choice (seq):\n    return seq [randint (0, len (seq) - 1)]\n\ndef random ():\n    return _random_integer () / _bitmask3\n    \nseed ()\n",
		"# File: transcript/modules/re/__init__.py\n# Author: Carl Allendorph\n# Date: 13NOV2016\n#\n# Description:\n#    This file contains the definition of a simulated re python\n# regular expression parsing module. The idea is to leverage the\n# javascript native regular expression interface as much as\n# possible. In fact, where necessary, this module chooses the\n# javascript idiosyncracies over the python ones.\n#\n#\n\nfrom org.transcrypt.stubs.browser import __pragma__\nfrom re.translate import translate\n\n\n# Flags\n\nT = (1<<0)\nTEMPLATE = T\n\nI = (1<<1)\nIGNORECASE = I\n\n# Deprecated\nL = (1<<2)\nLOCALE = L\n\nM = (1<<3)\nMULTILINE = M\n\nS = (1 << 4)\nDOTALL = S\n# Legacy - Unicode by default in Python 3\nU = (1 << 5)\nUNICODE = U\nX = (1 << 6)\nVERBOSE = X\nDEBUG = (1<<7)\n\nA = (1<<8)\nASCII = A\n\n# This is a javascript specific flag\nY = (1 << 16)\nSTICKY = Y\nG = (1 << 17)\nGLOBAL = G\n# This flag is used to indicate that re module should use\n# the javascript regex engine directly and not attempt to\n# translate the regex string into a python regex\nJ = (1<<19)\nJSSTRICT = J\n\n\n\nclass error(Exception):\n    \"\"\" Regular Expression Exception Class\n    \"\"\"\n    def __init__(self, msg, error, pattern = None, flags = 0, pos = None):\n        \"\"\"\n        \"\"\"\n        Exception.__init__(self, msg, error=error)\n        self.pattern = pattern\n        self.flags = flags\n        self.pos = pos\n        # @todo - lineno and colno attributes\n\nclass ReIndexError(IndexError):\n    \"\"\" Index Error variant for the re module - primarily used for\n    the group method in the Match Object.\n    \"\"\"\n    def __init__(self):\n        IndexError.__init__(self, \"no such group\")\n\nclass Match(object):\n    \"\"\" Resulting Match from a Regex Operation\n    \"\"\"\n    def __init__(self, mObj, string, pos, endpos, rObj, namedGroups = None):\n        \"\"\"\n        \"\"\"\n        # JS has two \"None\" values: `null` and `undefined`.\n        # `x is None` converts to `x === null`, which will fail if `x` is undefined.\n        # The js match object uses undefined for non-used capture groups,\n        # so it's not possible to find non-used groups by comparing with `None`,\n        # unless this conversion is made.\n        for index, match in enumerate(mObj):\n            mObj[index] = None if mObj[index] == js_undefined else mObj[index]\n        self._obj = mObj\n\n        self._pos = pos\n        self._endpos = endpos\n        self._re = rObj\n        self._string = string\n\n        self._namedGroups = namedGroups\n\n        self._lastindex = self._lastMatchGroup()\n        if ( self._namedGroups is not None ):\n            self._lastgroup = self._namedGroups[self._lastindex]\n        else:\n            # @note - javascript does not have the concept\n            #       of named groups so we will never be able to\n            #       implement this in raw RegExp\n            self._lastgroup = None\n\n    # Read-only Properties\n    def _getPos(self):\n        return(self._pos)\n    def _setPos(self, val):\n        raise AttributeError(\"readonly attribute\")\n    pos = property(_getPos, _setPos)\n\n    def _getEndPos(self):\n        return(self._endpos)\n    def _setEndPos(self, val):\n        raise AttributeError(\"readonly attribute\")\n    endpos = property(_getEndPos, _setEndPos)\n\n    def _getRe(self):\n        return(self._re)\n    def _setRe(self, val):\n        raise AttributeError(\"readonly attribute\")\n    re = property(_getRe, _setRe)\n\n    def _getString(self):\n        return(self._string)\n    def _setString(self, val):\n        raise AttributeError(\"readonly attribute\")\n    string = property(_getString, _setString)\n\n    def _getLastGroup(self):\n        return(self._lastgroup)\n    def _setLastGroup(self, val):\n        raise AttributeError(\"readonly attribute\")\n    lastgroup = property(_getLastGroup, _setLastGroup)\n\n    def _getLastIndex(self):\n        return(self._lastindex)\n    def _setLastIndex(self, val):\n        raise AttributeError(\"readonly attribute\")\n    lastindex = property(_getLastIndex, _setLastIndex)\n\n    def _lastMatchGroup(self):\n        \"\"\" Determine the last matching group in the object\n        \"\"\"\n        if ( len(self._obj) > 1 ):\n            for i in range(len(self._obj)-1,0,-1):\n                if (self._obj[i] is not None):\n                    return(i)\n            # None of the capture groups matched -\n            # this seems like it shouldn't happen\n            return(None)\n        else:\n            # No Capture Groups\n            return(None)\n\n    def expand(self, template):\n        \"\"\"\n        \"\"\"\n        raise NotImplementedError()\n\n    def group(self, *args):\n        \"\"\" Return the string[s] for a group[s]\n        if only one group is provided, a string is returned\n        if multiple groups are provided, a tuple of strings is returned\n        \"\"\"\n        ret = []\n        if ( len(args) > 0 ):\n            for index in args:\n                if type(index) is str:\n                    if self._namedGroups is not None:\n                        if ( index not in self._namedGroups.keys() ):\n                            raise ReIndexError()\n                        ret.append( self._obj[self._namedGroups[index]] )\n                    else:\n                        raise NotImplementedError(\"No NamedGroups Available\");\n                else:\n                    if ( index >= len(self._obj) ):\n                        # js will return an 'undefined' and we\n                        # want this to return an index error\n                        # Built-in Exceptions not defined ?\n                        raise ReIndexError()\n                    ret.append(self._obj[index])\n        else:\n            ret.append(self._obj[0])\n\n        if ( len(ret) == 1 ):\n            return(ret[0])\n        else:\n            return(tuple(ret))\n\n    def groups(self, default = None):\n        \"\"\" Get all the groups in this match. Replace any\n        groups that did not contribute to the match with default\n        value.\n        \"\"\"\n        if ( len(self._obj) > 1 ):\n            ret = self._obj[1:]\n            return(tuple([x if x is not None else default for x in ret]))\n        else:\n            return(tuple())\n\n    def groupdict(self, default = None):\n        \"\"\" The concept of named captures doesn't exist\n        in javascript so this will likely never be implemented.\n        For the python translated re we will have a group dict where\n        possible.\n        \"\"\"\n        if ( self._namedGroups is not None ):\n            ret = {}\n            for gName, gId in self._namedGroups.items():\n                value = self._obj[gId]\n                ret[gName] = value if value is not None else default\n            return(ret)\n        else:\n            # JS Only does not implement this\n            raise NotImplementedError(\"No NamedGroups Available\")\n\n    def start(self, group = 0):\n        \"\"\" Find the starting index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        \"\"\"\n        gId = 0\n        if ( type(group) is str ):\n            if ( self._namedGroups is not None):\n                if ( group not in self._namedGroups.keys() ):\n                    raise ReIndexError()\n                gId = self._namedGroups[group]\n            else:\n                raise NotImplementedError(\"No NamedGroups Available\")\n        else:\n            gId = group\n\n        if ( gId >= len(self._obj) ):\n            raise ReIndexError()\n\n        if ( gId == 0 ):\n            return(self._obj.index)\n        else:\n            # We don't really have a good way to do\n            # this in javascript. so we will attempt\n            # to match the string we found as a\n            # sub position in the main string - this\n            # isn't perfect though because you could\n            # create a capture that only matches on\n            # the last in a group - this is a difficult\n            # problem to solve without completely\n            # re-writing the regex engine from scratch.\n            if ( self._obj[gId] is not None ):\n                r = compile(escape(self._obj[gId]), self._re.flags)\n                m = r.search(self._obj[0])\n                if m:\n                    return(self._obj.index + m.start())\n                else:\n                    raise Exception(\"Failed to find capture group\")\n            else:\n                # This capture did not contribute the match.\n                return(-1)\n\n    def end(self, group = 0):\n        \"\"\" Find the ending index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        \"\"\"\n        gId = 0\n        if ( type(group) is str ):\n            if ( self._namedGroups is not None):\n                if ( group not in self._namedGroups.keys() ):\n                    raise ReIndexError()\n                gId = self._namedGroups[group]\n            else:\n                raise NotImplementedError(\"No NamedGroups Available\")\n        else:\n            gId = group\n\n        if ( gId >= len(self._obj) ):\n            raise ReIndexError()\n\n        if ( gId == 0 ):\n            return( self._obj.index + len(self._obj[0]))\n        else:\n            # We don't really have a good way to do\n            # this in javascript. so we will attempt\n            # to match the string we found as a\n            # sub position in the main string - this\n            # isn't perfect though because you could\n            # create a capture that only matches on\n            # the last in a group - this is a difficult\n            # problem to solve without completely\n            # re-writing the regex engine from scratch.\n            if ( self._obj[gId] is not None ):\n                r = compile(escape(self._obj[gId]), self._re.flags)\n                m = r.search(self._obj[0])\n                if m:\n                    return(self._obj.index + m.end())\n                else:\n                    raise Exception(\"Failed to find capture group\")\n            else:\n                # This capture did not contribute the match.\n                return(-1)\n\n    def span(self, group = 0):\n        \"\"\" Find the start and end index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        @return tuple of (start, end)\n        \"\"\"\n        return( (self.start(group), self.end(group)) )\n\nclass Regex(object):\n    \"\"\" Regular Expression Object\n    \"\"\"\n    def __init__(self, pattern, flags):\n        \"\"\" Initial the Regex Object\n        @param pattern - javascript regular expression pattern as a string\n        @param flags - string of javascript flags for the subsequently\n           created RegExp object.\n        \"\"\"\n        if ( not ((flags & ASCII) > 0) ):\n            flags |= UNICODE\n\n        self._flags = flags\n        self._jsFlags, self._obj = self._compileWrapper(pattern, flags)\n        self._jspattern = pattern\n        # For this regex object pypattern and jspattern are the\n        # same.\n        self._pypattern = pattern\n\n        # we will determine groups by using another regex\n        # that tacks on an empty match.\n        _, groupCounterRegex = self._compileWrapper(pattern + '|', flags)\n        self._groups = groupCounterRegex.exec('').length-1\n        # Javascript does not have named captures so this\n        # will never have content in js only mode\n        self._groupindex = None\n\n    # Read-only Properties\n    def _getPattern(self):\n        ret = self._pypattern.replace('\\\\', '\\\\\\\\')\n        return(ret)\n    def _setPattern(self, val):\n        raise AttributeError(\"readonly attribute\")\n    pattern = property(_getPattern, _setPattern)\n\n    def _getFlags(self):\n        return(self._flags)\n    def _setFlags(self, val):\n        raise AttributeError(\"readonly attribute\")\n    flags = property(_getFlags, _setFlags)\n\n    def _getGroups(self):\n        return(self._groups)\n    def _setGroups(self, val):\n        raise AttributeError(\"readonly attribute\")\n    groups = property(_getGroups, _setGroups)\n\n    def _getGroupIndex(self):\n        if ( self._groupindex is None ):\n            return({})\n        else:\n            return(self._groupindex)\n    def _setGroupIndex(self, val):\n        raise AttributeError(\"readonly attribute\")\n    groupindex = property(_getGroupIndex, _setGroupIndex)\n\n    def _compileWrapper(self, pattern, flags = 0):\n        \"\"\" This function wraps the creation of the the\n        regular expresion so that we can catch the\n        Syntax Error exception and turn it into a\n        Python Exception\n        \"\"\"\n        jsFlags = self._convertFlags(flags)\n\n        rObj = None\n        errObj = None\n        # The Exceptions need to be converted to python exceptions\n        # in order to propagate appropriately\n        __pragma__('js', '{}',\n                   '''\n                   try {\n                     rObj = new RegExp(pattern, jsFlags)\n                   } catch( err ) {\n                     errObj = err\n                   }\n                   ''')\n\n        if ( errObj is not None ):\n            raise error(errObj.message, errObj, pattern, flags)\n\n        return(jsFlags, rObj)\n\n    def _convertFlags(self, flags):\n        \"\"\" Convert the Integer map based flags to a\n        string list of flags for js\n        \"\"\"\n        bitmaps = [\n            (DEBUG , \"\"),\n            (IGNORECASE, \"i\"),\n            (MULTILINE, \"m\"),\n            (STICKY, \"y\"),\n            (GLOBAL, \"g\"),\n            (UNICODE, \"u\"),\n        ]\n        ret = \"\".join( [x[1] for x in bitmaps if (x[0] & flags) > 0] )\n        return(ret)\n\n    def _getTargetStr(self, string, pos, endpos):\n        \"\"\" Given an start and endpos, slice out a target string.\n        \"\"\"\n        endPtr = len(string)\n        if ( endpos is not None ):\n            if ( endpos < endPtr):\n                endPtr = endpos\n        if ( endPtr < 0 ):\n            endPtr = 0\n        ret = string[pos:endPtr]\n        return(ret)\n\n    def _patternHasCaptures(self):\n        \"\"\" Check if the regex pattern contains a capture\n        necessary to make split behave correctly\n        \"\"\"\n        return(self._groups > 0)\n\n    def search(self, string, pos=0, endpos=None):\n        \"\"\" Search through a string for matches to\n        this regex object. @see the python docs\n        \"\"\"\n        if ( endpos is None ):\n            endpos = len(string)\n        # @note - pos/endpos don't operate like a slice\n        #       here - we need to search complete string and then\n        #       reject if the match happens outside of pos:endpos\n        rObj = self._obj\n        m = rObj.exec(string)\n        if m:\n            if ( m.index < pos or m.index > endpos ):\n                return(None)\n            else:\n                # Valid match we will create a match object\n                return( Match(m, string, pos, endpos, self, self._groupindex))\n        else:\n            return(None)\n\n    def match(self, string, pos=0, endpos = None):\n        \"\"\" Match this regex at the beginning of the passed\n        string. @see the python docs\n        \"\"\"\n        target = string\n        if ( endpos is not None ):\n            target = target[:endpos]\n        else:\n            endpos = len(string)\n\n        rObj = self._obj\n        m = rObj.exec(target)\n        if m:\n            # Match only at the beginning\n            if ( m.index == pos ):\n                return( Match(m, string, pos, endpos, self, self._groupindex))\n            else:\n                return(None)\n        else:\n            return(None)\n\n    def fullmatch(self, string, pos=0, endpos = None):\n        \"\"\" Match the entirety of the passed string to this regex\n        object. @see the python docs\n        \"\"\"\n        target = string\n        strEndPos = len(string)\n        if ( endpos is not None ):\n            target = target[:endpos]\n            strEndPos = endpos\n\n        rObj = self._obj\n        m = rObj.exec(target)\n        if m:\n            obsEndPos = (m.index+len(m[0]))\n            if ( m.index == pos and obsEndPos == strEndPos ):\n                return( Match(m, string, pos, strEndPos, self, self._groupindex))\n            else:\n                return(None)\n        else:\n            return(None)\n\n    def split(self, string, maxsplit = 0):\n        \"\"\" Split the passed string on each match of this regex\n        object. If the regex contains captures, then the match\n        content is included as a separate item. If no captures are\n        in the regex, then only the non-matching split content is\n        returned. @see the python docs\n        @param maxsplit max number of times to split the string\n          at a matching substring.\n        @return list of sub-strings\n        \"\"\"\n        # JS split is slightly different from Python\n        # the \"limit\" arg limits the number of elements\n        # returned in the list - it doesn't limit the number of\n        # splits.\n\n        if ( maxsplit < 0 ):\n            return([string])\n\n        mObj = None\n        rObj = self._obj\n        if ( maxsplit == 0 ):\n            mObj = string.split(rObj)\n            return(mObj)\n        else:\n            # the split limit parameter in js does not behave like\n            # the maxsplit parameter in python - hence we need to\n            # do this manually.\n            # @todo - make this better handle the flags\n            flags = self._flags\n            flags |= GLOBAL\n\n            _, rObj = self._compileWrapper(self._jspattern, flags)\n            ret = []\n            lastM = None\n            cnt = 0\n            for i in range(0, maxsplit):\n                m = rObj.exec(string)\n                if m:\n                    cnt += 1\n                    if ( lastM is not None ):\n                        # subsequent match\n                        start = lastM.index + len(lastM[0])\n                        head = string[start:m.index]\n                        ret.append(head)\n                        if ( len(m) > 1 ):\n                            ret.extend(m[1:])\n                    else:\n                        # First match\n                        head = string[:m.index]\n                        ret.append(head)\n                        if ( len(m) > 1 ):\n                            ret.extend(m[1:])\n                    lastM = m\n                else:\n                    break\n\n            if ( lastM is not None ):\n                endPos = lastM.index + len(lastM[0])\n                end = string[endPos:]\n                ret.append(end)\n\n            return(ret)\n\n    def _findAllMatches(self, string, pos = 0, endpos = None):\n        target = self._getTargetStr(string, pos, endpos)\n\n        # Unfortunately, js RegExp.match does not behave\n        # like findall behaves in python - it doesn't\n        # pull out 'captures' like python expects so we\n        # are going to use RegExp.exec instead of match\n        flags = self._flags\n        flags |= GLOBAL\n\n        _, rObj = self._compileWrapper(self._jspattern, flags)\n        ret = []\n        while( True ):\n            m = rObj.exec(target)\n            if m:\n                ret.append(m)\n            else:\n                break\n        return(ret)\n\n    def findall(self, string, pos = 0, endpos = None):\n        \"\"\" Find All the matches to this regex in the passed string\n        @return either:\n          List of strings of the matched regex has 1 or 0 capture\n            groups\n          List of elements that are each a list of the groups matched\n            at each location in the string.\n        @see the python docs\n        \"\"\"\n        mlist = self._findAllMatches(string, pos, endpos)\n\n        def mSelect(m):\n            if ( len(m) > 2 ):\n                # Captures Present and we need to\n                # convert to a tuple\n                return(tuple(m[1:]))\n            elif ( len(m) == 2 ):\n                # 1 Capture\n                return(m[1])\n            else:\n                # No captures\n                return(m[0])\n\n        ret = map(mSelect, mlist)\n\n        return(ret)\n\n    def finditer(self, string, pos, endpos = None):\n        \"\"\" Like findall but returns an iterator instead of\n        a list.\n        @see the python docs\n        \"\"\"\n        # @note - Transcrypt compiled with `-e 5` does not have\n        #    iterator support at this point. Only `-e 6` has\n        #    iterator support.\n        __pragma__ ('ifdef', '__esv5__')\n        raise NotImplementedError(\"No Iterator Support in es5\")\n        __pragma__('else')\n        mlist = self._findAllMatches(string, pos, endpos)\n        ret = map(lambda m: Match(m, string, 0, len(string), self, self._groupindex), mlist)\n        return( iter(ret) )\n        __pragma__('endif')\n\n    def sub(self, repl, string, count = 0):\n        \"\"\" Substitude each match of this regex in the passed string\n        with either:\n          if repl is of type string,\n             replace with repl\n          if repl is a callable object, then the returned value\n            from repl(m) where m is the match object at a particular\n            point in the string.\n        @see the python docs\n        @return the augmented string with substitutions\n        \"\"\"\n        ret,_ = self.subn(repl, string, count)\n        return(ret)\n\n    def subn(self, repl, string, count = 0):\n        \"\"\" Similar to sub except that instead of just returning the\n        augmented string, it returns a tuple of the augmented string\n        and the number of times that the replacement op occured.\n        (augstr, numreplacements)\n        @see the python docs\n        \"\"\"\n        # For this we are going to use the 'exec' method\n        # because the 'replace' method in javascript is broken\n        # for what we are trying do. There is no way to get\n        # the function callback concept to work.\n        flags = self._flags\n        flags |= GLOBAL\n\n        _, rObj = self._compileWrapper(self._jspattern, flags)\n        ret = \"\"\n        totalMatch = 0\n        lastEnd = -1\n        while(True):\n            if (count > 0):\n                if ( totalMatch >= count ):\n                    if ( lastEnd < 0 ):\n                        # This is an odd case - if we got\n                        # here it means there is a bug in our code.\n                        return(ret,totalMatch)\n                    else:\n                        ret += string[lastEnd:m.index]\n                        return(ret,totalMatch)\n\n            m = rObj.exec(string)\n            if m:\n                if ( lastEnd < 0 ):\n                    # first match\n                    ret += string[:m.index]\n                else:\n                    # subsequent match\n                    ret += string[lastEnd:m.index]\n\n                if callable(repl):\n                    content = repl(Match(m, string, 0, len(string), self, self._groupindex))\n                    ret += content\n                else:\n                    ret += repl\n\n                totalMatch+=1\n                # Update the last end so we know where to start\n                # copying from on the next pass\n                lastEnd = m.index + len(m[0])\n            else:\n                # Failed to match means that there are no more\n                # matches in the string\n                if ( lastEnd < 0 ):\n                    # No matches were found - we return string\n                    # unmolested\n                    return(string, 0)\n                else:\n                    ret += string[lastEnd:]\n                    return(ret,totalMatch)\n\n\nclass PyRegExp(Regex):\n    \"\"\" Python Regular Expression object which translates a python\n    regex syntax string into a format that can be passed to the\n    js regex engine.\n    \"\"\"\n    def __init__(self, pyPattern, flags):\n        \"\"\"\n        @pattern Python Regex String\n        @pattern flags bit flags passed by the user.\n        \"\"\"\n        jsTokens, inlineFlags, namedGroups, nCapGroups, n_splits = translate(pyPattern)\n        flags |= inlineFlags\n\n        jsPattern = ''.join(jsTokens)\n        Regex.__init__(self, jsPattern, flags)\n        self._pypattern = pyPattern\n\n        self._nsplits = n_splits\n        self._jsTokens = jsTokens\n        # nCapGroups = the same as self.groups defined in the\n        #   base class.\n        self._capgroups = nCapGroups\n        self._groupindex = namedGroups\n\ndef compile(pattern, flags = 0):\n    \"\"\" Compile a regex object and return\n    an object that can be used for further processing.\n    \"\"\"\n    if ( flags & JSSTRICT ):\n        p = Regex(pattern, flags)\n    else:\n        p = PyRegExp(pattern, flags)\n    return(p)\n\ndef search(pattern, string, flags = 0):\n    \"\"\" Search a string for a particular matching pattern\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.search(string) )\n\ndef match(pattern, string, flags = 0):\n    \"\"\" Match a string for a particular pattern\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.match(string) )\n\ndef fullmatch(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.fullmatch(string) )\n\ndef split(pattern, string, maxsplit = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.split(string, maxsplit) )\n\ndef findall(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.findall(string) )\n\ndef finditer(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.finditer(string) )\n\ndef sub(pattern, repl, string, count = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.sub(repl, string, count) )\n\ndef subn(pattern, repl, string, count = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.subn(repl, string, count) )\n\ndef escape(string):\n    \"\"\" Escape a passed string so that we can send it to the\n    regular expressions engine.\n    \"\"\"\n    ret = None\n    def replfunc(m):\n        if ( m[0] == \"\\\\\" ):\n            return(\"\\\\\\\\\\\\\\\\\")\n        else:\n            return(\"\\\\\\\\\" + m[0])\n\n    # @note - I had an issue getting replfunc to be called in\n    #        javascript correctly when I didn't use this pragma\n    #        not sure if I was just doing it wrong or what\n    __pragma__(\n        'js', '{}',\n        '''\n        var r = /[^A-Za-z\\d]/g;\n        ret = string.replace(r, replfunc);\n        ''')\n    if ( ret is not None ):\n        return(ret)\n    else:\n        raise Exception(\"Failed to escape the passed string\")\n\ndef purge():\n    \"\"\" I think this function is unnecessary but included to keep interface\n    consistent.\n    \"\"\"\n    pass\n",
		"# Python RegExp Syntax to Javascript RegExp Syntax Translator\n# This code was pulled from the repository at:\n#   https://github.com/GULPF/rescrypt\n# Original license was MIT but was converted to Apache v2 for\n# ease of integrating with the Transcrypt project\n#\n\n\n__pragma__ ('tconv')\n\nVERBOSE = False\n\nMAX_SHIFTREDUCE_LOOPS = 1000\n\nstringFlags = 'aiLmsux'\n\n# Represents a regex group (e.g /()/, /(?:)/ /(?=), etc).\n# `start` and `end` is the index of the groups start and end token in the token list.\nclass Group:\n    def __init__(self, start, end, klass):\n        self.start = start\n        self.end = end\n        self.klass = klass\n\n    def __repr__(self):\n        return str((self.start, self.end, self.klass))\n\n\n# Generates a list of `Group`s from a token list.\ndef generateGroupSpans(tokens):\n    groupInfo = []\n\n    idx = 0\n    for token in tokens:\n        if token.name.startswith('('):\n            groupInfo.append(Group(idx, None, token.name))\n        elif token.name == ')':\n            for group in reversed(groupInfo):\n                if group.end is None:\n                    group.end = idx\n        idx += 1\n    return groupInfo\n\n\ndef countCaptureGroups(tokens):\n    groupInfo = generateGroupSpans(tokens)\n    count = 0\n\n    for token in tokens:\n        if token.name == '(':\n            count += 1\n\n    return count\n\n\n# Get the `Group` for a capture group with a given id or name.\ndef getCaptureGroup(groupInfo, namedGroups, groupRef):\n    try:\n        id = int(groupRef)\n    except:\n        id = namedGroups[groupRef]\n    search = 0\n    for group in groupInfo:\n        if group.klass == '(':\n            search += 1\n            if search == id:\n                return group\n\n\n# Regex conditionals is implemented by splitting the regex into two parts,\n# one for the if case and one for the else case.\n# Example: if the input is (a)?(b)?(?(1)a|c)(?(2)b|d),\n# the first conditional will cause it to split into these parts:\n# `()(b)?c(?(2)b|d)` and `(a)(b)?a(?(2)b|d)`\n# The second conditional will then cause each part to split into two, creating four parts in total:\n# `()()cd`, `()(b)cb`, `(a)()ad` and `(a)(b)ab`\n# The parts are then merged into a single regex: `part1|part2|part3|part4`.\n# TODO: This causes the group indexes to be messed up. To fix it, group indexes must be modified with `% len(groups) + 1`.\ndef splitIfElse(tokens, namedGroups):\n    variants = []\n    groupInfo = generateGroupSpans(tokens)\n\n    for group in groupInfo:\n        if group.klass == '(?<':\n            iff = tokens[:]\n            els = tokens[:]\n            conStart = group.start\n            conEnd   = group.end\n\n            ref = tokens[conStart + 1].name\n            captureGroup = getCaptureGroup(groupInfo, namedGroups, ref)\n            captureGroupModifier = tokens[captureGroup.end + 1]\n\n            if captureGroupModifier.name in ['?', '*'] or captureGroupModifier.name.startswith('{0,'):\n                if captureGroupModifier.name == '?':\n                    iff[captureGroup.end + 1] = None\n                elif captureGroupModifier.name == '*':\n                    iff[captureGroup.end + 1] = Token('+')\n                elif captureGroupModifier.name.startswith('{0,'):\n                    iff[captureGroup.end + 1].name[0:3] = '{1,'\n                els[captureGroup.end + 1] = None\n\n                hasElse = False\n                for idx in range(conStart, conEnd):\n                    if tokens[idx].name == '|':\n                        hasElse = True\n                        els.pop(conEnd)\n                        iff[idx:conEnd + 1] = []\n                        els[conStart:idx + 1] = []\n                        break\n\n                if not hasElse:\n                    els[conStart:conEnd + 1] = []\n                    iff.pop(conEnd)\n\n                iff[conStart:conStart + 3] = []\n                els[captureGroup.start:captureGroup.end + 1] = [Token('('), Token(')')]\n                iff.remove(None)\n                els.remove(None)\n                variants.append(iff)\n                variants.append(els)\n\n            else:  # the easy case - 'else' is impossible\n                pastIff = False\n                for idx in range(conStart, conEnd):\n                    if iff[idx].name == '|':\n                        iff = tokens[:idx]\n                        iff.extend(tokens[conEnd + 1:])\n                        break\n                iff[conStart:conStart + 3] = []\n                variants.append(iff)\n            break\n\n    if not variants:\n        return [tokens]\n\n    allVariants = []\n    for variant in variants:\n        allVariants.extend(splitIfElse(variant, namedGroups))\n    return allVariants\n\n\nclass Token:\n    def __init__(self, name, paras=None, pure=False):\n        if paras is None:\n            paras = []\n        self.name  = name\n        self.paras = paras\n        self.pure = pure\n        # tmp until I have thought of something better\n        self.isModeGroup = False\n\n    def __repr__(self):\n        return self.name\n\n    def resolve(self):\n        paras = ''\n        for para in self.paras:\n            paras += str(para)\n\n        return self.name + paras\n\n\ndef shift(stack, queue):\n    done = not bool(queue)\n    if not done:\n        stack.append(Token(queue[0], [], True))\n        queue = queue[1:]\n    return stack, queue, done\n\n\n# Shift-reduce parser. Creates the next state of the stack & queue.\ndef shiftReduce(stack, queue, namedGroups, flags):\n    done = False\n    high = len(stack) - 1\n\n    if len(stack) < 2:\n        stack, queue, done = shift(stack, queue)\n        return stack, queue, flags, done\n\n    s0 = stack[high]     if len(stack) > 0 else Token('')\n    s1 = stack[high - 1] if len(stack) > 1 else Token('')\n\n    if VERBOSE:\n        for token in stack:\n            console.log(token.resolve(), '\\t', end='')\n        console.log('')\n\n    if s1.name == '\\\\':\n        if s0.name == 'A':\n            stack[-2:] = [Token('^')]\n\n        elif s0.name == 'a':\n            stack[-2:] = [Token('\\\\07')]\n\n        elif s0.name == 'Z':\n            stack[-2:] = [Token('$')]\n\n        else:\n            stack[-2:] = [Token('\\\\' + s0.name)]\n\n    elif s0.name == '$' and s0.pure:\n        stack.pop()\n        stack.extend([Token('(?='), Token('\\\\n'), Token('?'), Token('$'), Token(')')])\n\n    elif s1.name == '{':\n        if s0.name == ',' and len(s1.paras) == 0:\n            s1.paras.append('0')\n            s1.paras.append(',')\n        else:\n            if s0.name == '}':\n                s1.paras.append('}')\n                s1.name = s1.resolve()\n                s1.paras = []\n            else:\n                s1.paras.append(s0.name)\n\n        stack = stack[:-1]\n\n    elif s1.name == '[' and s0.name == '^':\n        stack[-2:] = [Token('[^')]\n\n    elif s1.name == '(' and s0.name == '?':\n        stack[-2:] = [Token('(?')]\n\n    elif s1.name in ['*', '+', '?'] and s0.name == '?':\n        stack[-2:] = [Token(s1.name + '?')]\n\n    elif s1.isModeGroup and s0.name == ')':\n        stack = stack[:-2]\n\n    elif s1.name == '(?':\n        if s0.name in stringFlags:\n            if s0.name == 'i':\n                flags |= re.IGNORECASE\n            elif s0.name == 'L':\n                flags |= re.LOCALE\n            elif s0.name == 'm':\n                flags |= re.MULTILINE\n            elif s0.name == 's':\n                flags |= re.DOTALL\n            elif s0.name == 'u':\n                flags |= re.UNICODE\n            elif s0.name == 'x':\n                flags |= re.VERBOSE\n            elif s0.name == 'a':\n                flags |= re.ASCII\n\n            stack.pop()\n            s1.isModeGroup = True\n\n        else:\n            if s0.name == '(':\n                s0.name = '<'\n\n            newToken = Token('(?' + s0.name)\n            stack[-2:] = [newToken]\n\n    elif s1.name == '(?<':\n        if s0.name == ')':\n            stack[-1:] = [Token(''.join(s1.paras)), Token('>')]\n            s1.paras = []\n        else:\n            s1.paras.append(s0.name)\n            stack.pop()\n\n    elif s1.name == '(?P':\n        stack[-2:] = [Token('(?P' + s0.name)]\n\n    elif s1.name == '(?P<':\n        if s0.name == '>':\n            # todo: don't count every time, just keep track of it over time\n            namedGroups[''.join(s1.paras)] = countCaptureGroups(stack) + 1\n            stack[-2:] = [Token('(')]\n        else:\n            s1.paras.append(s0.name)\n            stack.pop()\n\n    elif s1.name == '(?P=':\n        if s0.name == ')':\n            stack[-2:] = [Token('\\\\' + str(namedGroups[s1.paras[0]]))]\n        elif not s1.paras:\n            s1.paras.append(s0.name)\n            stack.pop()\n        else:\n            s1.paras[0] += s0.name\n            stack.pop()\n\n    elif s1.name == '(?#':\n        if s0.name == ')':\n            stack = stack[:-2]\n        else:\n            stack = stack[:-1]\n\n    else:\n        stack, queue, done = shift(stack, queue)\n\n    return stack, queue, flags, done\n\n\n# Takes a re-regex and returns a js-regex.\n# TODO: Returns way to many values.\ndef translate(rgx):\n    # can't import as normal because it's a circular dependency\n    import re\n    stack = []\n    queue = list(rgx)\n\n    flags = 0\n    namedGroups = dict()\n\n    nloop = 0\n\n    while True:\n        nloop += 1\n        if nloop > MAX_SHIFTREDUCE_LOOPS:\n            raise Exception()\n\n        stack, queue, flags, done = shiftReduce(stack, queue, namedGroups, flags)\n        if done:\n            break\n\n    variants = splitIfElse(stack, namedGroups)\n    n_splits = len(variants)\n\n    final = []\n    for i in range(0, len(variants)):\n        final.extend(variants[i])\n        if i < len(variants) - 1:\n            final.append(Token('|'))\n    stack = final\n\n    groupInfo = generateGroupSpans(stack)\n    resolvedTokens = []\n\n    for token in stack:\n        stringed = token.resolve()\n        if (flags & re.DOTALL) and stringed == '.':\n            stringed = '[\\s\\S]'\n        resolvedTokens.append(stringed)\n    return resolvedTokens, flags, namedGroups, countCaptureGroups(stack), n_splits\n",
		"import pyreact\nfrom clock import Clock\n\n\n############################################\n###   Top-level component\n\nclass App(pyreact.Component):\n    def __init__(self, props):\n        # very important to call super\n        super().__init__(props)\n        \n        # state dictionary, just like in JS\n        self.state = {\n            'hour': 0,\n            'minute': 0,\n            'second': 0,\n        }\n        \n\n    def render(self):\n        # using self.element() factory function and returning a list as an example.\n        # see clock.py for the more common self.jsx().\n        return [\n            'The current time is ',\n            self.element(Clock, { \n                'hour': self.state.hour, \n                'minute': self.state.minute,\n                'second': self.state.second,\n                'key': 'clock',\n            }),\n            '.',\n        ]\n\n\n    # called after first render\n    def componentDidMount(self):\n        def ticktock():\n            # create a JS Date object the transcrypt way\n            d = __new__(Date())\n            self.setState({\n                'hour': d.getHours(),\n                'minute': d.getMinutes(),\n                'second': d.getSeconds(),\n            })\n        self.timer = window.setInterval(ticktock, 200);\n    \n    \n    # caled before removal from page\n    def componentWillUnmount(self):\n        window.clearInterval(self.timer);\n    \n    \n############################################\n###   Main method that bootstraps React\n\ndef main():\n    # using React.createElement directly\n    ReactDOM.render(\n        React.createElement(App, {}),\n        document.getElementById('approot')\n    );\n\n\n# run main() when the document is ready\ndocument.addEventListener(\"DOMContentLoaded\", main)\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAMA;AAAA;AAKA;AAAA;AAGA;AAAA;AAGA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoFA;AAUA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACh5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2DA;AAAA;AA3DA;AACA;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAEA;AAIA;AAAA;AAIA;AAIA;AAAA;AAcA;AAEA;AAAA;AAAA;AAQA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiGA;AA3FA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAcA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACjGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAKA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAIA;AACA;AAAA;AAAA;AAEA;AAGA;AAAA;AAAA;AAAA;AAQA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAIA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AArNA;AAMA;AAMA;AAMA;AAMA;AAMA;AAyLA;AAGA;AAMA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AAGA;AAIA;AAAA;AAAA;AACA;AAGA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAMA;AAEA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAIA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAeA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAEA;AACA;AAGA;AAAA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAWA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAWA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAMA;AAAA;AAIA;AAGA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AArVA;AAMA;AAMA;AASA;AAmUA;AAKA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC/yBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoVA;AA1UA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACpVA;AAiEA;AAjEA;AACA;AAMA;AACA;AAEA;AAGA;AAAA;AAOA;AAKA;AAAA;AAWA;AACA;AAEA;AAIA;AAAA;AAEA;AAAA;AAIA;AACA;AAAA;AAAA;AAMA;AAIA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}